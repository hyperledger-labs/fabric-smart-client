/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package network

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/hyperledger-labs/fabric-smart-client/integration/nwo/fabric/commands"
	"github.com/hyperledger-labs/fabric-smart-client/integration/nwo/fabric/topology"
	"github.com/hyperledger-labs/fabric-smart-client/integration/nwo/fsc"
	"github.com/hyperledger-labs/fabric-smart-client/integration/nwo/fsc/node"
	"github.com/onsi/gomega"
	"github.com/onsi/gomega/gexec"
)

func createMetanamespaceKey(n *Network) error {
	isApprover := func(options *node.Options) bool {
		o := options.Get("approver.role")
		return o != nil && o != ""
	}

	// workout the public key for the meta namespace verification key
	fscTopology, ok := n.Context.TopologyByName("fsc").(*fsc.Topology)
	if !ok {
		panic("programming error: must be a fsc.Topology")
	}

	var approvers []*node.Node
	for _, nn := range fscTopology.Nodes {
		if isApprover(nn.Options) {
			approvers = append(approvers, nn)
		}
	}

	if len(approvers) != 1 {
		panic(fmt.Errorf("exactly one approver allowed, %d found", len(approvers)))
	}

	user := approvers[0].Name
	p := n.PeerByName(user)
	certPath := n.PeerUserCert(p, user)
	certBytes, err := os.ReadFile(certPath)
	if err != nil {
		return err
	}

	pkPath := filepath.Join(n.RootDir, n.Prefix, "crypto", "sc_pubkey.pem")
	logger.Infof("Write user [%s] pk from [%s] to [%s]", user, certPath, pkPath)
	return os.WriteFile(pkPath, certBytes, 0o644)
}

func createChannelBlock(n *Network, c *topology.Channel) commands.OutputBlock {
	return commands.OutputBlock{
		NetworkPrefix: n.Prefix,
		ChannelID:     c.Name,
		Profile:       c.Profile,
		ConfigPath:    filepath.Join(n.Context.RootDir(), n.Prefix),
		OutputBlock:   n.OutputBlockPath(c.Name),
	}
}

// bootstrapIdemix creates the idemix-related crypto material.
func bootstrapIdemix(n *Network) {
	for _, org := range n.IdemixOrgs() {
		output := n.IdemixOrgMSPDir(org)
		// - ca-keygen
		sess, err := n.Idemixgen(commands.CAKeyGen{
			NetworkPrefix: n.Prefix,
			Output:        output,
		})
		gomega.Expect(err).NotTo(gomega.HaveOccurred())
		gomega.Eventually(sess, n.EventuallyTimeout).Should(gexec.Exit(0))
	}
}

func bootstrapExtraIdentities(n *Network) {
	for i, peer := range n.Peers {
		for j, identity := range peer.Identities {
			switch identity.MSPType {
			case "idemix":
				org := n.Organization(identity.Org)
				output := n.IdemixOrgMSPDir(org)
				userOutput := filepath.Join(n.PeerLocalIdemixExtraIdentitiesDir(peer), identity.ID)
				sess, err := n.Idemixgen(commands.SignerConfig{
					NetworkPrefix:    n.Prefix,
					CAInput:          output,
					Output:           userOutput,
					OrgUnit:          org.Domain,
					EnrollmentID:     identity.EnrollmentID,
					RevocationHandle: fmt.Sprintf("1%d%d", i, j),
				})
				gomega.Expect(err).NotTo(gomega.HaveOccurred())
				gomega.Eventually(sess, n.EventuallyTimeout).Should(gexec.Exit(0))
			case "bccsp":
				// Nothing to do here cause the extra identities are generated by crypto gen.
			default:
				gomega.Expect(identity.MSPType).To(gomega.Equal("idemix"))
			}
		}
	}
}
