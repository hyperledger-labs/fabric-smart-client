// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"
	"time"

	"github.com/hyperledger-labs/fabric-smart-client/platform/fabric/core/generic/msp/driver"
	drivera "github.com/hyperledger-labs/fabric-smart-client/platform/fabric/driver"
	driverb "github.com/hyperledger-labs/fabric-smart-client/platform/view/services/db/driver"
	"github.com/hyperledger-labs/fabric-smart-client/platform/view/services/grpc"
)

type ConfigProvider struct {
	BroadcastNumRetriesStub        func() int
	broadcastNumRetriesMutex       sync.RWMutex
	broadcastNumRetriesArgsForCall []struct {
	}
	broadcastNumRetriesReturns struct {
		result1 int
	}
	broadcastNumRetriesReturnsOnCall map[int]struct {
		result1 int
	}
	BroadcastRetryIntervalStub        func() time.Duration
	broadcastRetryIntervalMutex       sync.RWMutex
	broadcastRetryIntervalArgsForCall []struct {
	}
	broadcastRetryIntervalReturns struct {
		result1 time.Duration
	}
	broadcastRetryIntervalReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	ChannelStub        func(string) drivera.ChannelConfig
	channelMutex       sync.RWMutex
	channelArgsForCall []struct {
		arg1 string
	}
	channelReturns struct {
		result1 drivera.ChannelConfig
	}
	channelReturnsOnCall map[int]struct {
		result1 drivera.ChannelConfig
	}
	ChannelIDsStub        func() []string
	channelIDsMutex       sync.RWMutex
	channelIDsArgsForCall []struct {
	}
	channelIDsReturns struct {
		result1 []string
	}
	channelIDsReturnsOnCall map[int]struct {
		result1 []string
	}
	ClientConnTimeoutStub        func() time.Duration
	clientConnTimeoutMutex       sync.RWMutex
	clientConnTimeoutArgsForCall []struct {
	}
	clientConnTimeoutReturns struct {
		result1 time.Duration
	}
	clientConnTimeoutReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	ConfigFileUsedStub        func() string
	configFileUsedMutex       sync.RWMutex
	configFileUsedArgsForCall []struct {
	}
	configFileUsedReturns struct {
		result1 string
	}
	configFileUsedReturnsOnCall map[int]struct {
		result1 string
	}
	DefaultChannelStub        func() string
	defaultChannelMutex       sync.RWMutex
	defaultChannelArgsForCall []struct {
	}
	defaultChannelReturns struct {
		result1 string
	}
	defaultChannelReturnsOnCall map[int]struct {
		result1 string
	}
	GetBoolStub        func(string) bool
	getBoolMutex       sync.RWMutex
	getBoolArgsForCall []struct {
		arg1 string
	}
	getBoolReturns struct {
		result1 bool
	}
	getBoolReturnsOnCall map[int]struct {
		result1 bool
	}
	GetDurationStub        func(string) time.Duration
	getDurationMutex       sync.RWMutex
	getDurationArgsForCall []struct {
		arg1 string
	}
	getDurationReturns struct {
		result1 time.Duration
	}
	getDurationReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	GetIntStub        func(string) int
	getIntMutex       sync.RWMutex
	getIntArgsForCall []struct {
		arg1 string
	}
	getIntReturns struct {
		result1 int
	}
	getIntReturnsOnCall map[int]struct {
		result1 int
	}
	GetPathStub        func(string) string
	getPathMutex       sync.RWMutex
	getPathArgsForCall []struct {
		arg1 string
	}
	getPathReturns struct {
		result1 string
	}
	getPathReturnsOnCall map[int]struct {
		result1 string
	}
	GetStringStub        func(string) string
	getStringMutex       sync.RWMutex
	getStringArgsForCall []struct {
		arg1 string
	}
	getStringReturns struct {
		result1 string
	}
	getStringReturnsOnCall map[int]struct {
		result1 string
	}
	GetStringSliceStub        func(string) []string
	getStringSliceMutex       sync.RWMutex
	getStringSliceArgsForCall []struct {
		arg1 string
	}
	getStringSliceReturns struct {
		result1 []string
	}
	getStringSliceReturnsOnCall map[int]struct {
		result1 []string
	}
	IsChannelQuietStub        func(string) bool
	isChannelQuietMutex       sync.RWMutex
	isChannelQuietArgsForCall []struct {
		arg1 string
	}
	isChannelQuietReturns struct {
		result1 bool
	}
	isChannelQuietReturnsOnCall map[int]struct {
		result1 bool
	}
	IsSetStub        func(string) bool
	isSetMutex       sync.RWMutex
	isSetArgsForCall []struct {
		arg1 string
	}
	isSetReturns struct {
		result1 bool
	}
	isSetReturnsOnCall map[int]struct {
		result1 bool
	}
	KeepAliveClientIntervalStub        func() time.Duration
	keepAliveClientIntervalMutex       sync.RWMutex
	keepAliveClientIntervalArgsForCall []struct {
	}
	keepAliveClientIntervalReturns struct {
		result1 time.Duration
	}
	keepAliveClientIntervalReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	KeepAliveClientTimeoutStub        func() time.Duration
	keepAliveClientTimeoutMutex       sync.RWMutex
	keepAliveClientTimeoutArgsForCall []struct {
	}
	keepAliveClientTimeoutReturns struct {
		result1 time.Duration
	}
	keepAliveClientTimeoutReturnsOnCall map[int]struct {
		result1 time.Duration
	}
	NetworkNameStub        func() string
	networkNameMutex       sync.RWMutex
	networkNameArgsForCall []struct {
	}
	networkNameReturns struct {
		result1 string
	}
	networkNameReturnsOnCall map[int]struct {
		result1 string
	}
	NewDefaultChannelConfigStub        func(string) drivera.ChannelConfig
	newDefaultChannelConfigMutex       sync.RWMutex
	newDefaultChannelConfigArgsForCall []struct {
		arg1 string
	}
	newDefaultChannelConfigReturns struct {
		result1 drivera.ChannelConfig
	}
	newDefaultChannelConfigReturnsOnCall map[int]struct {
		result1 drivera.ChannelConfig
	}
	OrdererConnectionPoolSizeStub        func() int
	ordererConnectionPoolSizeMutex       sync.RWMutex
	ordererConnectionPoolSizeArgsForCall []struct {
	}
	ordererConnectionPoolSizeReturns struct {
		result1 int
	}
	ordererConnectionPoolSizeReturnsOnCall map[int]struct {
		result1 int
	}
	OrderersStub        func() []*grpc.ConnectionConfig
	orderersMutex       sync.RWMutex
	orderersArgsForCall []struct {
	}
	orderersReturns struct {
		result1 []*grpc.ConnectionConfig
	}
	orderersReturnsOnCall map[int]struct {
		result1 []*grpc.ConnectionConfig
	}
	PickOrdererStub        func() *grpc.ConnectionConfig
	pickOrdererMutex       sync.RWMutex
	pickOrdererArgsForCall []struct {
	}
	pickOrdererReturns struct {
		result1 *grpc.ConnectionConfig
	}
	pickOrdererReturnsOnCall map[int]struct {
		result1 *grpc.ConnectionConfig
	}
	PickPeerStub        func(drivera.PeerFunctionType) *grpc.ConnectionConfig
	pickPeerMutex       sync.RWMutex
	pickPeerArgsForCall []struct {
		arg1 drivera.PeerFunctionType
	}
	pickPeerReturns struct {
		result1 *grpc.ConnectionConfig
	}
	pickPeerReturnsOnCall map[int]struct {
		result1 *grpc.ConnectionConfig
	}
	SetConfigOrderersStub        func([]*grpc.ConnectionConfig) error
	setConfigOrderersMutex       sync.RWMutex
	setConfigOrderersArgsForCall []struct {
		arg1 []*grpc.ConnectionConfig
	}
	setConfigOrderersReturns struct {
		result1 error
	}
	setConfigOrderersReturnsOnCall map[int]struct {
		result1 error
	}
	TLSClientAuthRequiredStub        func() bool
	tLSClientAuthRequiredMutex       sync.RWMutex
	tLSClientAuthRequiredArgsForCall []struct {
	}
	tLSClientAuthRequiredReturns struct {
		result1 bool
	}
	tLSClientAuthRequiredReturnsOnCall map[int]struct {
		result1 bool
	}
	TLSClientCertFileStub        func() string
	tLSClientCertFileMutex       sync.RWMutex
	tLSClientCertFileArgsForCall []struct {
	}
	tLSClientCertFileReturns struct {
		result1 string
	}
	tLSClientCertFileReturnsOnCall map[int]struct {
		result1 string
	}
	TLSClientKeyFileStub        func() string
	tLSClientKeyFileMutex       sync.RWMutex
	tLSClientKeyFileArgsForCall []struct {
	}
	tLSClientKeyFileReturns struct {
		result1 string
	}
	tLSClientKeyFileReturnsOnCall map[int]struct {
		result1 string
	}
	TLSEnabledStub        func() bool
	tLSEnabledMutex       sync.RWMutex
	tLSEnabledArgsForCall []struct {
	}
	tLSEnabledReturns struct {
		result1 bool
	}
	tLSEnabledReturnsOnCall map[int]struct {
		result1 bool
	}
	TLSServerHostOverrideStub        func() string
	tLSServerHostOverrideMutex       sync.RWMutex
	tLSServerHostOverrideArgsForCall []struct {
	}
	tLSServerHostOverrideReturns struct {
		result1 string
	}
	tLSServerHostOverrideReturnsOnCall map[int]struct {
		result1 string
	}
	TranslatePathStub        func(string) string
	translatePathMutex       sync.RWMutex
	translatePathArgsForCall []struct {
		arg1 string
	}
	translatePathReturns struct {
		result1 string
	}
	translatePathReturnsOnCall map[int]struct {
		result1 string
	}
	UnmarshalKeyStub        func(string, interface{}) error
	unmarshalKeyMutex       sync.RWMutex
	unmarshalKeyArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	unmarshalKeyReturns struct {
		result1 error
	}
	unmarshalKeyReturnsOnCall map[int]struct {
		result1 error
	}
	VaultPersistencePrefixStub        func() string
	vaultPersistencePrefixMutex       sync.RWMutex
	vaultPersistencePrefixArgsForCall []struct {
	}
	vaultPersistencePrefixReturns struct {
		result1 string
	}
	vaultPersistencePrefixReturnsOnCall map[int]struct {
		result1 string
	}
	VaultPersistenceTypeStub        func() driverb.PersistenceType
	vaultPersistenceTypeMutex       sync.RWMutex
	vaultPersistenceTypeArgsForCall []struct {
	}
	vaultPersistenceTypeReturns struct {
		result1 driverb.PersistenceType
	}
	vaultPersistenceTypeReturnsOnCall map[int]struct {
		result1 driverb.PersistenceType
	}
	VaultTXStoreCacheSizeStub        func() int
	vaultTXStoreCacheSizeMutex       sync.RWMutex
	vaultTXStoreCacheSizeArgsForCall []struct {
	}
	vaultTXStoreCacheSizeReturns struct {
		result1 int
	}
	vaultTXStoreCacheSizeReturnsOnCall map[int]struct {
		result1 int
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ConfigProvider) BroadcastNumRetries() int {
	fake.broadcastNumRetriesMutex.Lock()
	ret, specificReturn := fake.broadcastNumRetriesReturnsOnCall[len(fake.broadcastNumRetriesArgsForCall)]
	fake.broadcastNumRetriesArgsForCall = append(fake.broadcastNumRetriesArgsForCall, struct {
	}{})
	stub := fake.BroadcastNumRetriesStub
	fakeReturns := fake.broadcastNumRetriesReturns
	fake.recordInvocation("BroadcastNumRetries", []interface{}{})
	fake.broadcastNumRetriesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) BroadcastNumRetriesCallCount() int {
	fake.broadcastNumRetriesMutex.RLock()
	defer fake.broadcastNumRetriesMutex.RUnlock()
	return len(fake.broadcastNumRetriesArgsForCall)
}

func (fake *ConfigProvider) BroadcastNumRetriesCalls(stub func() int) {
	fake.broadcastNumRetriesMutex.Lock()
	defer fake.broadcastNumRetriesMutex.Unlock()
	fake.BroadcastNumRetriesStub = stub
}

func (fake *ConfigProvider) BroadcastNumRetriesReturns(result1 int) {
	fake.broadcastNumRetriesMutex.Lock()
	defer fake.broadcastNumRetriesMutex.Unlock()
	fake.BroadcastNumRetriesStub = nil
	fake.broadcastNumRetriesReturns = struct {
		result1 int
	}{result1}
}

func (fake *ConfigProvider) BroadcastNumRetriesReturnsOnCall(i int, result1 int) {
	fake.broadcastNumRetriesMutex.Lock()
	defer fake.broadcastNumRetriesMutex.Unlock()
	fake.BroadcastNumRetriesStub = nil
	if fake.broadcastNumRetriesReturnsOnCall == nil {
		fake.broadcastNumRetriesReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.broadcastNumRetriesReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *ConfigProvider) BroadcastRetryInterval() time.Duration {
	fake.broadcastRetryIntervalMutex.Lock()
	ret, specificReturn := fake.broadcastRetryIntervalReturnsOnCall[len(fake.broadcastRetryIntervalArgsForCall)]
	fake.broadcastRetryIntervalArgsForCall = append(fake.broadcastRetryIntervalArgsForCall, struct {
	}{})
	stub := fake.BroadcastRetryIntervalStub
	fakeReturns := fake.broadcastRetryIntervalReturns
	fake.recordInvocation("BroadcastRetryInterval", []interface{}{})
	fake.broadcastRetryIntervalMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) BroadcastRetryIntervalCallCount() int {
	fake.broadcastRetryIntervalMutex.RLock()
	defer fake.broadcastRetryIntervalMutex.RUnlock()
	return len(fake.broadcastRetryIntervalArgsForCall)
}

func (fake *ConfigProvider) BroadcastRetryIntervalCalls(stub func() time.Duration) {
	fake.broadcastRetryIntervalMutex.Lock()
	defer fake.broadcastRetryIntervalMutex.Unlock()
	fake.BroadcastRetryIntervalStub = stub
}

func (fake *ConfigProvider) BroadcastRetryIntervalReturns(result1 time.Duration) {
	fake.broadcastRetryIntervalMutex.Lock()
	defer fake.broadcastRetryIntervalMutex.Unlock()
	fake.BroadcastRetryIntervalStub = nil
	fake.broadcastRetryIntervalReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *ConfigProvider) BroadcastRetryIntervalReturnsOnCall(i int, result1 time.Duration) {
	fake.broadcastRetryIntervalMutex.Lock()
	defer fake.broadcastRetryIntervalMutex.Unlock()
	fake.BroadcastRetryIntervalStub = nil
	if fake.broadcastRetryIntervalReturnsOnCall == nil {
		fake.broadcastRetryIntervalReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.broadcastRetryIntervalReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *ConfigProvider) Channel(arg1 string) drivera.ChannelConfig {
	fake.channelMutex.Lock()
	ret, specificReturn := fake.channelReturnsOnCall[len(fake.channelArgsForCall)]
	fake.channelArgsForCall = append(fake.channelArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ChannelStub
	fakeReturns := fake.channelReturns
	fake.recordInvocation("Channel", []interface{}{arg1})
	fake.channelMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) ChannelCallCount() int {
	fake.channelMutex.RLock()
	defer fake.channelMutex.RUnlock()
	return len(fake.channelArgsForCall)
}

func (fake *ConfigProvider) ChannelCalls(stub func(string) drivera.ChannelConfig) {
	fake.channelMutex.Lock()
	defer fake.channelMutex.Unlock()
	fake.ChannelStub = stub
}

func (fake *ConfigProvider) ChannelArgsForCall(i int) string {
	fake.channelMutex.RLock()
	defer fake.channelMutex.RUnlock()
	argsForCall := fake.channelArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ConfigProvider) ChannelReturns(result1 drivera.ChannelConfig) {
	fake.channelMutex.Lock()
	defer fake.channelMutex.Unlock()
	fake.ChannelStub = nil
	fake.channelReturns = struct {
		result1 drivera.ChannelConfig
	}{result1}
}

func (fake *ConfigProvider) ChannelReturnsOnCall(i int, result1 drivera.ChannelConfig) {
	fake.channelMutex.Lock()
	defer fake.channelMutex.Unlock()
	fake.ChannelStub = nil
	if fake.channelReturnsOnCall == nil {
		fake.channelReturnsOnCall = make(map[int]struct {
			result1 drivera.ChannelConfig
		})
	}
	fake.channelReturnsOnCall[i] = struct {
		result1 drivera.ChannelConfig
	}{result1}
}

func (fake *ConfigProvider) ChannelIDs() []string {
	fake.channelIDsMutex.Lock()
	ret, specificReturn := fake.channelIDsReturnsOnCall[len(fake.channelIDsArgsForCall)]
	fake.channelIDsArgsForCall = append(fake.channelIDsArgsForCall, struct {
	}{})
	stub := fake.ChannelIDsStub
	fakeReturns := fake.channelIDsReturns
	fake.recordInvocation("ChannelIDs", []interface{}{})
	fake.channelIDsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) ChannelIDsCallCount() int {
	fake.channelIDsMutex.RLock()
	defer fake.channelIDsMutex.RUnlock()
	return len(fake.channelIDsArgsForCall)
}

func (fake *ConfigProvider) ChannelIDsCalls(stub func() []string) {
	fake.channelIDsMutex.Lock()
	defer fake.channelIDsMutex.Unlock()
	fake.ChannelIDsStub = stub
}

func (fake *ConfigProvider) ChannelIDsReturns(result1 []string) {
	fake.channelIDsMutex.Lock()
	defer fake.channelIDsMutex.Unlock()
	fake.ChannelIDsStub = nil
	fake.channelIDsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *ConfigProvider) ChannelIDsReturnsOnCall(i int, result1 []string) {
	fake.channelIDsMutex.Lock()
	defer fake.channelIDsMutex.Unlock()
	fake.ChannelIDsStub = nil
	if fake.channelIDsReturnsOnCall == nil {
		fake.channelIDsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.channelIDsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *ConfigProvider) ClientConnTimeout() time.Duration {
	fake.clientConnTimeoutMutex.Lock()
	ret, specificReturn := fake.clientConnTimeoutReturnsOnCall[len(fake.clientConnTimeoutArgsForCall)]
	fake.clientConnTimeoutArgsForCall = append(fake.clientConnTimeoutArgsForCall, struct {
	}{})
	stub := fake.ClientConnTimeoutStub
	fakeReturns := fake.clientConnTimeoutReturns
	fake.recordInvocation("ClientConnTimeout", []interface{}{})
	fake.clientConnTimeoutMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) ClientConnTimeoutCallCount() int {
	fake.clientConnTimeoutMutex.RLock()
	defer fake.clientConnTimeoutMutex.RUnlock()
	return len(fake.clientConnTimeoutArgsForCall)
}

func (fake *ConfigProvider) ClientConnTimeoutCalls(stub func() time.Duration) {
	fake.clientConnTimeoutMutex.Lock()
	defer fake.clientConnTimeoutMutex.Unlock()
	fake.ClientConnTimeoutStub = stub
}

func (fake *ConfigProvider) ClientConnTimeoutReturns(result1 time.Duration) {
	fake.clientConnTimeoutMutex.Lock()
	defer fake.clientConnTimeoutMutex.Unlock()
	fake.ClientConnTimeoutStub = nil
	fake.clientConnTimeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *ConfigProvider) ClientConnTimeoutReturnsOnCall(i int, result1 time.Duration) {
	fake.clientConnTimeoutMutex.Lock()
	defer fake.clientConnTimeoutMutex.Unlock()
	fake.ClientConnTimeoutStub = nil
	if fake.clientConnTimeoutReturnsOnCall == nil {
		fake.clientConnTimeoutReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.clientConnTimeoutReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *ConfigProvider) ConfigFileUsed() string {
	fake.configFileUsedMutex.Lock()
	ret, specificReturn := fake.configFileUsedReturnsOnCall[len(fake.configFileUsedArgsForCall)]
	fake.configFileUsedArgsForCall = append(fake.configFileUsedArgsForCall, struct {
	}{})
	stub := fake.ConfigFileUsedStub
	fakeReturns := fake.configFileUsedReturns
	fake.recordInvocation("ConfigFileUsed", []interface{}{})
	fake.configFileUsedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) ConfigFileUsedCallCount() int {
	fake.configFileUsedMutex.RLock()
	defer fake.configFileUsedMutex.RUnlock()
	return len(fake.configFileUsedArgsForCall)
}

func (fake *ConfigProvider) ConfigFileUsedCalls(stub func() string) {
	fake.configFileUsedMutex.Lock()
	defer fake.configFileUsedMutex.Unlock()
	fake.ConfigFileUsedStub = stub
}

func (fake *ConfigProvider) ConfigFileUsedReturns(result1 string) {
	fake.configFileUsedMutex.Lock()
	defer fake.configFileUsedMutex.Unlock()
	fake.ConfigFileUsedStub = nil
	fake.configFileUsedReturns = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) ConfigFileUsedReturnsOnCall(i int, result1 string) {
	fake.configFileUsedMutex.Lock()
	defer fake.configFileUsedMutex.Unlock()
	fake.ConfigFileUsedStub = nil
	if fake.configFileUsedReturnsOnCall == nil {
		fake.configFileUsedReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.configFileUsedReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) DefaultChannel() string {
	fake.defaultChannelMutex.Lock()
	ret, specificReturn := fake.defaultChannelReturnsOnCall[len(fake.defaultChannelArgsForCall)]
	fake.defaultChannelArgsForCall = append(fake.defaultChannelArgsForCall, struct {
	}{})
	stub := fake.DefaultChannelStub
	fakeReturns := fake.defaultChannelReturns
	fake.recordInvocation("DefaultChannel", []interface{}{})
	fake.defaultChannelMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) DefaultChannelCallCount() int {
	fake.defaultChannelMutex.RLock()
	defer fake.defaultChannelMutex.RUnlock()
	return len(fake.defaultChannelArgsForCall)
}

func (fake *ConfigProvider) DefaultChannelCalls(stub func() string) {
	fake.defaultChannelMutex.Lock()
	defer fake.defaultChannelMutex.Unlock()
	fake.DefaultChannelStub = stub
}

func (fake *ConfigProvider) DefaultChannelReturns(result1 string) {
	fake.defaultChannelMutex.Lock()
	defer fake.defaultChannelMutex.Unlock()
	fake.DefaultChannelStub = nil
	fake.defaultChannelReturns = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) DefaultChannelReturnsOnCall(i int, result1 string) {
	fake.defaultChannelMutex.Lock()
	defer fake.defaultChannelMutex.Unlock()
	fake.DefaultChannelStub = nil
	if fake.defaultChannelReturnsOnCall == nil {
		fake.defaultChannelReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.defaultChannelReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) GetBool(arg1 string) bool {
	fake.getBoolMutex.Lock()
	ret, specificReturn := fake.getBoolReturnsOnCall[len(fake.getBoolArgsForCall)]
	fake.getBoolArgsForCall = append(fake.getBoolArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetBoolStub
	fakeReturns := fake.getBoolReturns
	fake.recordInvocation("GetBool", []interface{}{arg1})
	fake.getBoolMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) GetBoolCallCount() int {
	fake.getBoolMutex.RLock()
	defer fake.getBoolMutex.RUnlock()
	return len(fake.getBoolArgsForCall)
}

func (fake *ConfigProvider) GetBoolCalls(stub func(string) bool) {
	fake.getBoolMutex.Lock()
	defer fake.getBoolMutex.Unlock()
	fake.GetBoolStub = stub
}

func (fake *ConfigProvider) GetBoolArgsForCall(i int) string {
	fake.getBoolMutex.RLock()
	defer fake.getBoolMutex.RUnlock()
	argsForCall := fake.getBoolArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ConfigProvider) GetBoolReturns(result1 bool) {
	fake.getBoolMutex.Lock()
	defer fake.getBoolMutex.Unlock()
	fake.GetBoolStub = nil
	fake.getBoolReturns = struct {
		result1 bool
	}{result1}
}

func (fake *ConfigProvider) GetBoolReturnsOnCall(i int, result1 bool) {
	fake.getBoolMutex.Lock()
	defer fake.getBoolMutex.Unlock()
	fake.GetBoolStub = nil
	if fake.getBoolReturnsOnCall == nil {
		fake.getBoolReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.getBoolReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *ConfigProvider) GetDuration(arg1 string) time.Duration {
	fake.getDurationMutex.Lock()
	ret, specificReturn := fake.getDurationReturnsOnCall[len(fake.getDurationArgsForCall)]
	fake.getDurationArgsForCall = append(fake.getDurationArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetDurationStub
	fakeReturns := fake.getDurationReturns
	fake.recordInvocation("GetDuration", []interface{}{arg1})
	fake.getDurationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) GetDurationCallCount() int {
	fake.getDurationMutex.RLock()
	defer fake.getDurationMutex.RUnlock()
	return len(fake.getDurationArgsForCall)
}

func (fake *ConfigProvider) GetDurationCalls(stub func(string) time.Duration) {
	fake.getDurationMutex.Lock()
	defer fake.getDurationMutex.Unlock()
	fake.GetDurationStub = stub
}

func (fake *ConfigProvider) GetDurationArgsForCall(i int) string {
	fake.getDurationMutex.RLock()
	defer fake.getDurationMutex.RUnlock()
	argsForCall := fake.getDurationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ConfigProvider) GetDurationReturns(result1 time.Duration) {
	fake.getDurationMutex.Lock()
	defer fake.getDurationMutex.Unlock()
	fake.GetDurationStub = nil
	fake.getDurationReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *ConfigProvider) GetDurationReturnsOnCall(i int, result1 time.Duration) {
	fake.getDurationMutex.Lock()
	defer fake.getDurationMutex.Unlock()
	fake.GetDurationStub = nil
	if fake.getDurationReturnsOnCall == nil {
		fake.getDurationReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.getDurationReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *ConfigProvider) GetInt(arg1 string) int {
	fake.getIntMutex.Lock()
	ret, specificReturn := fake.getIntReturnsOnCall[len(fake.getIntArgsForCall)]
	fake.getIntArgsForCall = append(fake.getIntArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetIntStub
	fakeReturns := fake.getIntReturns
	fake.recordInvocation("GetInt", []interface{}{arg1})
	fake.getIntMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) GetIntCallCount() int {
	fake.getIntMutex.RLock()
	defer fake.getIntMutex.RUnlock()
	return len(fake.getIntArgsForCall)
}

func (fake *ConfigProvider) GetIntCalls(stub func(string) int) {
	fake.getIntMutex.Lock()
	defer fake.getIntMutex.Unlock()
	fake.GetIntStub = stub
}

func (fake *ConfigProvider) GetIntArgsForCall(i int) string {
	fake.getIntMutex.RLock()
	defer fake.getIntMutex.RUnlock()
	argsForCall := fake.getIntArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ConfigProvider) GetIntReturns(result1 int) {
	fake.getIntMutex.Lock()
	defer fake.getIntMutex.Unlock()
	fake.GetIntStub = nil
	fake.getIntReturns = struct {
		result1 int
	}{result1}
}

func (fake *ConfigProvider) GetIntReturnsOnCall(i int, result1 int) {
	fake.getIntMutex.Lock()
	defer fake.getIntMutex.Unlock()
	fake.GetIntStub = nil
	if fake.getIntReturnsOnCall == nil {
		fake.getIntReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getIntReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *ConfigProvider) GetPath(arg1 string) string {
	fake.getPathMutex.Lock()
	ret, specificReturn := fake.getPathReturnsOnCall[len(fake.getPathArgsForCall)]
	fake.getPathArgsForCall = append(fake.getPathArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetPathStub
	fakeReturns := fake.getPathReturns
	fake.recordInvocation("GetPath", []interface{}{arg1})
	fake.getPathMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) GetPathCallCount() int {
	fake.getPathMutex.RLock()
	defer fake.getPathMutex.RUnlock()
	return len(fake.getPathArgsForCall)
}

func (fake *ConfigProvider) GetPathCalls(stub func(string) string) {
	fake.getPathMutex.Lock()
	defer fake.getPathMutex.Unlock()
	fake.GetPathStub = stub
}

func (fake *ConfigProvider) GetPathArgsForCall(i int) string {
	fake.getPathMutex.RLock()
	defer fake.getPathMutex.RUnlock()
	argsForCall := fake.getPathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ConfigProvider) GetPathReturns(result1 string) {
	fake.getPathMutex.Lock()
	defer fake.getPathMutex.Unlock()
	fake.GetPathStub = nil
	fake.getPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) GetPathReturnsOnCall(i int, result1 string) {
	fake.getPathMutex.Lock()
	defer fake.getPathMutex.Unlock()
	fake.GetPathStub = nil
	if fake.getPathReturnsOnCall == nil {
		fake.getPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) GetString(arg1 string) string {
	fake.getStringMutex.Lock()
	ret, specificReturn := fake.getStringReturnsOnCall[len(fake.getStringArgsForCall)]
	fake.getStringArgsForCall = append(fake.getStringArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStringStub
	fakeReturns := fake.getStringReturns
	fake.recordInvocation("GetString", []interface{}{arg1})
	fake.getStringMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) GetStringCallCount() int {
	fake.getStringMutex.RLock()
	defer fake.getStringMutex.RUnlock()
	return len(fake.getStringArgsForCall)
}

func (fake *ConfigProvider) GetStringCalls(stub func(string) string) {
	fake.getStringMutex.Lock()
	defer fake.getStringMutex.Unlock()
	fake.GetStringStub = stub
}

func (fake *ConfigProvider) GetStringArgsForCall(i int) string {
	fake.getStringMutex.RLock()
	defer fake.getStringMutex.RUnlock()
	argsForCall := fake.getStringArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ConfigProvider) GetStringReturns(result1 string) {
	fake.getStringMutex.Lock()
	defer fake.getStringMutex.Unlock()
	fake.GetStringStub = nil
	fake.getStringReturns = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) GetStringReturnsOnCall(i int, result1 string) {
	fake.getStringMutex.Lock()
	defer fake.getStringMutex.Unlock()
	fake.GetStringStub = nil
	if fake.getStringReturnsOnCall == nil {
		fake.getStringReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getStringReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) GetStringSlice(arg1 string) []string {
	fake.getStringSliceMutex.Lock()
	ret, specificReturn := fake.getStringSliceReturnsOnCall[len(fake.getStringSliceArgsForCall)]
	fake.getStringSliceArgsForCall = append(fake.getStringSliceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStringSliceStub
	fakeReturns := fake.getStringSliceReturns
	fake.recordInvocation("GetStringSlice", []interface{}{arg1})
	fake.getStringSliceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) GetStringSliceCallCount() int {
	fake.getStringSliceMutex.RLock()
	defer fake.getStringSliceMutex.RUnlock()
	return len(fake.getStringSliceArgsForCall)
}

func (fake *ConfigProvider) GetStringSliceCalls(stub func(string) []string) {
	fake.getStringSliceMutex.Lock()
	defer fake.getStringSliceMutex.Unlock()
	fake.GetStringSliceStub = stub
}

func (fake *ConfigProvider) GetStringSliceArgsForCall(i int) string {
	fake.getStringSliceMutex.RLock()
	defer fake.getStringSliceMutex.RUnlock()
	argsForCall := fake.getStringSliceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ConfigProvider) GetStringSliceReturns(result1 []string) {
	fake.getStringSliceMutex.Lock()
	defer fake.getStringSliceMutex.Unlock()
	fake.GetStringSliceStub = nil
	fake.getStringSliceReturns = struct {
		result1 []string
	}{result1}
}

func (fake *ConfigProvider) GetStringSliceReturnsOnCall(i int, result1 []string) {
	fake.getStringSliceMutex.Lock()
	defer fake.getStringSliceMutex.Unlock()
	fake.GetStringSliceStub = nil
	if fake.getStringSliceReturnsOnCall == nil {
		fake.getStringSliceReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getStringSliceReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *ConfigProvider) IsChannelQuiet(arg1 string) bool {
	fake.isChannelQuietMutex.Lock()
	ret, specificReturn := fake.isChannelQuietReturnsOnCall[len(fake.isChannelQuietArgsForCall)]
	fake.isChannelQuietArgsForCall = append(fake.isChannelQuietArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IsChannelQuietStub
	fakeReturns := fake.isChannelQuietReturns
	fake.recordInvocation("IsChannelQuiet", []interface{}{arg1})
	fake.isChannelQuietMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) IsChannelQuietCallCount() int {
	fake.isChannelQuietMutex.RLock()
	defer fake.isChannelQuietMutex.RUnlock()
	return len(fake.isChannelQuietArgsForCall)
}

func (fake *ConfigProvider) IsChannelQuietCalls(stub func(string) bool) {
	fake.isChannelQuietMutex.Lock()
	defer fake.isChannelQuietMutex.Unlock()
	fake.IsChannelQuietStub = stub
}

func (fake *ConfigProvider) IsChannelQuietArgsForCall(i int) string {
	fake.isChannelQuietMutex.RLock()
	defer fake.isChannelQuietMutex.RUnlock()
	argsForCall := fake.isChannelQuietArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ConfigProvider) IsChannelQuietReturns(result1 bool) {
	fake.isChannelQuietMutex.Lock()
	defer fake.isChannelQuietMutex.Unlock()
	fake.IsChannelQuietStub = nil
	fake.isChannelQuietReturns = struct {
		result1 bool
	}{result1}
}

func (fake *ConfigProvider) IsChannelQuietReturnsOnCall(i int, result1 bool) {
	fake.isChannelQuietMutex.Lock()
	defer fake.isChannelQuietMutex.Unlock()
	fake.IsChannelQuietStub = nil
	if fake.isChannelQuietReturnsOnCall == nil {
		fake.isChannelQuietReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isChannelQuietReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *ConfigProvider) IsSet(arg1 string) bool {
	fake.isSetMutex.Lock()
	ret, specificReturn := fake.isSetReturnsOnCall[len(fake.isSetArgsForCall)]
	fake.isSetArgsForCall = append(fake.isSetArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IsSetStub
	fakeReturns := fake.isSetReturns
	fake.recordInvocation("IsSet", []interface{}{arg1})
	fake.isSetMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) IsSetCallCount() int {
	fake.isSetMutex.RLock()
	defer fake.isSetMutex.RUnlock()
	return len(fake.isSetArgsForCall)
}

func (fake *ConfigProvider) IsSetCalls(stub func(string) bool) {
	fake.isSetMutex.Lock()
	defer fake.isSetMutex.Unlock()
	fake.IsSetStub = stub
}

func (fake *ConfigProvider) IsSetArgsForCall(i int) string {
	fake.isSetMutex.RLock()
	defer fake.isSetMutex.RUnlock()
	argsForCall := fake.isSetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ConfigProvider) IsSetReturns(result1 bool) {
	fake.isSetMutex.Lock()
	defer fake.isSetMutex.Unlock()
	fake.IsSetStub = nil
	fake.isSetReturns = struct {
		result1 bool
	}{result1}
}

func (fake *ConfigProvider) IsSetReturnsOnCall(i int, result1 bool) {
	fake.isSetMutex.Lock()
	defer fake.isSetMutex.Unlock()
	fake.IsSetStub = nil
	if fake.isSetReturnsOnCall == nil {
		fake.isSetReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isSetReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *ConfigProvider) KeepAliveClientInterval() time.Duration {
	fake.keepAliveClientIntervalMutex.Lock()
	ret, specificReturn := fake.keepAliveClientIntervalReturnsOnCall[len(fake.keepAliveClientIntervalArgsForCall)]
	fake.keepAliveClientIntervalArgsForCall = append(fake.keepAliveClientIntervalArgsForCall, struct {
	}{})
	stub := fake.KeepAliveClientIntervalStub
	fakeReturns := fake.keepAliveClientIntervalReturns
	fake.recordInvocation("KeepAliveClientInterval", []interface{}{})
	fake.keepAliveClientIntervalMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) KeepAliveClientIntervalCallCount() int {
	fake.keepAliveClientIntervalMutex.RLock()
	defer fake.keepAliveClientIntervalMutex.RUnlock()
	return len(fake.keepAliveClientIntervalArgsForCall)
}

func (fake *ConfigProvider) KeepAliveClientIntervalCalls(stub func() time.Duration) {
	fake.keepAliveClientIntervalMutex.Lock()
	defer fake.keepAliveClientIntervalMutex.Unlock()
	fake.KeepAliveClientIntervalStub = stub
}

func (fake *ConfigProvider) KeepAliveClientIntervalReturns(result1 time.Duration) {
	fake.keepAliveClientIntervalMutex.Lock()
	defer fake.keepAliveClientIntervalMutex.Unlock()
	fake.KeepAliveClientIntervalStub = nil
	fake.keepAliveClientIntervalReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *ConfigProvider) KeepAliveClientIntervalReturnsOnCall(i int, result1 time.Duration) {
	fake.keepAliveClientIntervalMutex.Lock()
	defer fake.keepAliveClientIntervalMutex.Unlock()
	fake.KeepAliveClientIntervalStub = nil
	if fake.keepAliveClientIntervalReturnsOnCall == nil {
		fake.keepAliveClientIntervalReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.keepAliveClientIntervalReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *ConfigProvider) KeepAliveClientTimeout() time.Duration {
	fake.keepAliveClientTimeoutMutex.Lock()
	ret, specificReturn := fake.keepAliveClientTimeoutReturnsOnCall[len(fake.keepAliveClientTimeoutArgsForCall)]
	fake.keepAliveClientTimeoutArgsForCall = append(fake.keepAliveClientTimeoutArgsForCall, struct {
	}{})
	stub := fake.KeepAliveClientTimeoutStub
	fakeReturns := fake.keepAliveClientTimeoutReturns
	fake.recordInvocation("KeepAliveClientTimeout", []interface{}{})
	fake.keepAliveClientTimeoutMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) KeepAliveClientTimeoutCallCount() int {
	fake.keepAliveClientTimeoutMutex.RLock()
	defer fake.keepAliveClientTimeoutMutex.RUnlock()
	return len(fake.keepAliveClientTimeoutArgsForCall)
}

func (fake *ConfigProvider) KeepAliveClientTimeoutCalls(stub func() time.Duration) {
	fake.keepAliveClientTimeoutMutex.Lock()
	defer fake.keepAliveClientTimeoutMutex.Unlock()
	fake.KeepAliveClientTimeoutStub = stub
}

func (fake *ConfigProvider) KeepAliveClientTimeoutReturns(result1 time.Duration) {
	fake.keepAliveClientTimeoutMutex.Lock()
	defer fake.keepAliveClientTimeoutMutex.Unlock()
	fake.KeepAliveClientTimeoutStub = nil
	fake.keepAliveClientTimeoutReturns = struct {
		result1 time.Duration
	}{result1}
}

func (fake *ConfigProvider) KeepAliveClientTimeoutReturnsOnCall(i int, result1 time.Duration) {
	fake.keepAliveClientTimeoutMutex.Lock()
	defer fake.keepAliveClientTimeoutMutex.Unlock()
	fake.KeepAliveClientTimeoutStub = nil
	if fake.keepAliveClientTimeoutReturnsOnCall == nil {
		fake.keepAliveClientTimeoutReturnsOnCall = make(map[int]struct {
			result1 time.Duration
		})
	}
	fake.keepAliveClientTimeoutReturnsOnCall[i] = struct {
		result1 time.Duration
	}{result1}
}

func (fake *ConfigProvider) NetworkName() string {
	fake.networkNameMutex.Lock()
	ret, specificReturn := fake.networkNameReturnsOnCall[len(fake.networkNameArgsForCall)]
	fake.networkNameArgsForCall = append(fake.networkNameArgsForCall, struct {
	}{})
	stub := fake.NetworkNameStub
	fakeReturns := fake.networkNameReturns
	fake.recordInvocation("NetworkName", []interface{}{})
	fake.networkNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) NetworkNameCallCount() int {
	fake.networkNameMutex.RLock()
	defer fake.networkNameMutex.RUnlock()
	return len(fake.networkNameArgsForCall)
}

func (fake *ConfigProvider) NetworkNameCalls(stub func() string) {
	fake.networkNameMutex.Lock()
	defer fake.networkNameMutex.Unlock()
	fake.NetworkNameStub = stub
}

func (fake *ConfigProvider) NetworkNameReturns(result1 string) {
	fake.networkNameMutex.Lock()
	defer fake.networkNameMutex.Unlock()
	fake.NetworkNameStub = nil
	fake.networkNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) NetworkNameReturnsOnCall(i int, result1 string) {
	fake.networkNameMutex.Lock()
	defer fake.networkNameMutex.Unlock()
	fake.NetworkNameStub = nil
	if fake.networkNameReturnsOnCall == nil {
		fake.networkNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.networkNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) NewDefaultChannelConfig(arg1 string) drivera.ChannelConfig {
	fake.newDefaultChannelConfigMutex.Lock()
	ret, specificReturn := fake.newDefaultChannelConfigReturnsOnCall[len(fake.newDefaultChannelConfigArgsForCall)]
	fake.newDefaultChannelConfigArgsForCall = append(fake.newDefaultChannelConfigArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.NewDefaultChannelConfigStub
	fakeReturns := fake.newDefaultChannelConfigReturns
	fake.recordInvocation("NewDefaultChannelConfig", []interface{}{arg1})
	fake.newDefaultChannelConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) NewDefaultChannelConfigCallCount() int {
	fake.newDefaultChannelConfigMutex.RLock()
	defer fake.newDefaultChannelConfigMutex.RUnlock()
	return len(fake.newDefaultChannelConfigArgsForCall)
}

func (fake *ConfigProvider) NewDefaultChannelConfigCalls(stub func(string) drivera.ChannelConfig) {
	fake.newDefaultChannelConfigMutex.Lock()
	defer fake.newDefaultChannelConfigMutex.Unlock()
	fake.NewDefaultChannelConfigStub = stub
}

func (fake *ConfigProvider) NewDefaultChannelConfigArgsForCall(i int) string {
	fake.newDefaultChannelConfigMutex.RLock()
	defer fake.newDefaultChannelConfigMutex.RUnlock()
	argsForCall := fake.newDefaultChannelConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ConfigProvider) NewDefaultChannelConfigReturns(result1 drivera.ChannelConfig) {
	fake.newDefaultChannelConfigMutex.Lock()
	defer fake.newDefaultChannelConfigMutex.Unlock()
	fake.NewDefaultChannelConfigStub = nil
	fake.newDefaultChannelConfigReturns = struct {
		result1 drivera.ChannelConfig
	}{result1}
}

func (fake *ConfigProvider) NewDefaultChannelConfigReturnsOnCall(i int, result1 drivera.ChannelConfig) {
	fake.newDefaultChannelConfigMutex.Lock()
	defer fake.newDefaultChannelConfigMutex.Unlock()
	fake.NewDefaultChannelConfigStub = nil
	if fake.newDefaultChannelConfigReturnsOnCall == nil {
		fake.newDefaultChannelConfigReturnsOnCall = make(map[int]struct {
			result1 drivera.ChannelConfig
		})
	}
	fake.newDefaultChannelConfigReturnsOnCall[i] = struct {
		result1 drivera.ChannelConfig
	}{result1}
}

func (fake *ConfigProvider) OrdererConnectionPoolSize() int {
	fake.ordererConnectionPoolSizeMutex.Lock()
	ret, specificReturn := fake.ordererConnectionPoolSizeReturnsOnCall[len(fake.ordererConnectionPoolSizeArgsForCall)]
	fake.ordererConnectionPoolSizeArgsForCall = append(fake.ordererConnectionPoolSizeArgsForCall, struct {
	}{})
	stub := fake.OrdererConnectionPoolSizeStub
	fakeReturns := fake.ordererConnectionPoolSizeReturns
	fake.recordInvocation("OrdererConnectionPoolSize", []interface{}{})
	fake.ordererConnectionPoolSizeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) OrdererConnectionPoolSizeCallCount() int {
	fake.ordererConnectionPoolSizeMutex.RLock()
	defer fake.ordererConnectionPoolSizeMutex.RUnlock()
	return len(fake.ordererConnectionPoolSizeArgsForCall)
}

func (fake *ConfigProvider) OrdererConnectionPoolSizeCalls(stub func() int) {
	fake.ordererConnectionPoolSizeMutex.Lock()
	defer fake.ordererConnectionPoolSizeMutex.Unlock()
	fake.OrdererConnectionPoolSizeStub = stub
}

func (fake *ConfigProvider) OrdererConnectionPoolSizeReturns(result1 int) {
	fake.ordererConnectionPoolSizeMutex.Lock()
	defer fake.ordererConnectionPoolSizeMutex.Unlock()
	fake.OrdererConnectionPoolSizeStub = nil
	fake.ordererConnectionPoolSizeReturns = struct {
		result1 int
	}{result1}
}

func (fake *ConfigProvider) OrdererConnectionPoolSizeReturnsOnCall(i int, result1 int) {
	fake.ordererConnectionPoolSizeMutex.Lock()
	defer fake.ordererConnectionPoolSizeMutex.Unlock()
	fake.OrdererConnectionPoolSizeStub = nil
	if fake.ordererConnectionPoolSizeReturnsOnCall == nil {
		fake.ordererConnectionPoolSizeReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.ordererConnectionPoolSizeReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *ConfigProvider) Orderers() []*grpc.ConnectionConfig {
	fake.orderersMutex.Lock()
	ret, specificReturn := fake.orderersReturnsOnCall[len(fake.orderersArgsForCall)]
	fake.orderersArgsForCall = append(fake.orderersArgsForCall, struct {
	}{})
	stub := fake.OrderersStub
	fakeReturns := fake.orderersReturns
	fake.recordInvocation("Orderers", []interface{}{})
	fake.orderersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) OrderersCallCount() int {
	fake.orderersMutex.RLock()
	defer fake.orderersMutex.RUnlock()
	return len(fake.orderersArgsForCall)
}

func (fake *ConfigProvider) OrderersCalls(stub func() []*grpc.ConnectionConfig) {
	fake.orderersMutex.Lock()
	defer fake.orderersMutex.Unlock()
	fake.OrderersStub = stub
}

func (fake *ConfigProvider) OrderersReturns(result1 []*grpc.ConnectionConfig) {
	fake.orderersMutex.Lock()
	defer fake.orderersMutex.Unlock()
	fake.OrderersStub = nil
	fake.orderersReturns = struct {
		result1 []*grpc.ConnectionConfig
	}{result1}
}

func (fake *ConfigProvider) OrderersReturnsOnCall(i int, result1 []*grpc.ConnectionConfig) {
	fake.orderersMutex.Lock()
	defer fake.orderersMutex.Unlock()
	fake.OrderersStub = nil
	if fake.orderersReturnsOnCall == nil {
		fake.orderersReturnsOnCall = make(map[int]struct {
			result1 []*grpc.ConnectionConfig
		})
	}
	fake.orderersReturnsOnCall[i] = struct {
		result1 []*grpc.ConnectionConfig
	}{result1}
}

func (fake *ConfigProvider) PickOrderer() *grpc.ConnectionConfig {
	fake.pickOrdererMutex.Lock()
	ret, specificReturn := fake.pickOrdererReturnsOnCall[len(fake.pickOrdererArgsForCall)]
	fake.pickOrdererArgsForCall = append(fake.pickOrdererArgsForCall, struct {
	}{})
	stub := fake.PickOrdererStub
	fakeReturns := fake.pickOrdererReturns
	fake.recordInvocation("PickOrderer", []interface{}{})
	fake.pickOrdererMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) PickOrdererCallCount() int {
	fake.pickOrdererMutex.RLock()
	defer fake.pickOrdererMutex.RUnlock()
	return len(fake.pickOrdererArgsForCall)
}

func (fake *ConfigProvider) PickOrdererCalls(stub func() *grpc.ConnectionConfig) {
	fake.pickOrdererMutex.Lock()
	defer fake.pickOrdererMutex.Unlock()
	fake.PickOrdererStub = stub
}

func (fake *ConfigProvider) PickOrdererReturns(result1 *grpc.ConnectionConfig) {
	fake.pickOrdererMutex.Lock()
	defer fake.pickOrdererMutex.Unlock()
	fake.PickOrdererStub = nil
	fake.pickOrdererReturns = struct {
		result1 *grpc.ConnectionConfig
	}{result1}
}

func (fake *ConfigProvider) PickOrdererReturnsOnCall(i int, result1 *grpc.ConnectionConfig) {
	fake.pickOrdererMutex.Lock()
	defer fake.pickOrdererMutex.Unlock()
	fake.PickOrdererStub = nil
	if fake.pickOrdererReturnsOnCall == nil {
		fake.pickOrdererReturnsOnCall = make(map[int]struct {
			result1 *grpc.ConnectionConfig
		})
	}
	fake.pickOrdererReturnsOnCall[i] = struct {
		result1 *grpc.ConnectionConfig
	}{result1}
}

func (fake *ConfigProvider) PickPeer(arg1 drivera.PeerFunctionType) *grpc.ConnectionConfig {
	fake.pickPeerMutex.Lock()
	ret, specificReturn := fake.pickPeerReturnsOnCall[len(fake.pickPeerArgsForCall)]
	fake.pickPeerArgsForCall = append(fake.pickPeerArgsForCall, struct {
		arg1 drivera.PeerFunctionType
	}{arg1})
	stub := fake.PickPeerStub
	fakeReturns := fake.pickPeerReturns
	fake.recordInvocation("PickPeer", []interface{}{arg1})
	fake.pickPeerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) PickPeerCallCount() int {
	fake.pickPeerMutex.RLock()
	defer fake.pickPeerMutex.RUnlock()
	return len(fake.pickPeerArgsForCall)
}

func (fake *ConfigProvider) PickPeerCalls(stub func(drivera.PeerFunctionType) *grpc.ConnectionConfig) {
	fake.pickPeerMutex.Lock()
	defer fake.pickPeerMutex.Unlock()
	fake.PickPeerStub = stub
}

func (fake *ConfigProvider) PickPeerArgsForCall(i int) drivera.PeerFunctionType {
	fake.pickPeerMutex.RLock()
	defer fake.pickPeerMutex.RUnlock()
	argsForCall := fake.pickPeerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ConfigProvider) PickPeerReturns(result1 *grpc.ConnectionConfig) {
	fake.pickPeerMutex.Lock()
	defer fake.pickPeerMutex.Unlock()
	fake.PickPeerStub = nil
	fake.pickPeerReturns = struct {
		result1 *grpc.ConnectionConfig
	}{result1}
}

func (fake *ConfigProvider) PickPeerReturnsOnCall(i int, result1 *grpc.ConnectionConfig) {
	fake.pickPeerMutex.Lock()
	defer fake.pickPeerMutex.Unlock()
	fake.PickPeerStub = nil
	if fake.pickPeerReturnsOnCall == nil {
		fake.pickPeerReturnsOnCall = make(map[int]struct {
			result1 *grpc.ConnectionConfig
		})
	}
	fake.pickPeerReturnsOnCall[i] = struct {
		result1 *grpc.ConnectionConfig
	}{result1}
}

func (fake *ConfigProvider) SetConfigOrderers(arg1 []*grpc.ConnectionConfig) error {
	var arg1Copy []*grpc.ConnectionConfig
	if arg1 != nil {
		arg1Copy = make([]*grpc.ConnectionConfig, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setConfigOrderersMutex.Lock()
	ret, specificReturn := fake.setConfigOrderersReturnsOnCall[len(fake.setConfigOrderersArgsForCall)]
	fake.setConfigOrderersArgsForCall = append(fake.setConfigOrderersArgsForCall, struct {
		arg1 []*grpc.ConnectionConfig
	}{arg1Copy})
	stub := fake.SetConfigOrderersStub
	fakeReturns := fake.setConfigOrderersReturns
	fake.recordInvocation("SetConfigOrderers", []interface{}{arg1Copy})
	fake.setConfigOrderersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) SetConfigOrderersCallCount() int {
	fake.setConfigOrderersMutex.RLock()
	defer fake.setConfigOrderersMutex.RUnlock()
	return len(fake.setConfigOrderersArgsForCall)
}

func (fake *ConfigProvider) SetConfigOrderersCalls(stub func([]*grpc.ConnectionConfig) error) {
	fake.setConfigOrderersMutex.Lock()
	defer fake.setConfigOrderersMutex.Unlock()
	fake.SetConfigOrderersStub = stub
}

func (fake *ConfigProvider) SetConfigOrderersArgsForCall(i int) []*grpc.ConnectionConfig {
	fake.setConfigOrderersMutex.RLock()
	defer fake.setConfigOrderersMutex.RUnlock()
	argsForCall := fake.setConfigOrderersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ConfigProvider) SetConfigOrderersReturns(result1 error) {
	fake.setConfigOrderersMutex.Lock()
	defer fake.setConfigOrderersMutex.Unlock()
	fake.SetConfigOrderersStub = nil
	fake.setConfigOrderersReturns = struct {
		result1 error
	}{result1}
}

func (fake *ConfigProvider) SetConfigOrderersReturnsOnCall(i int, result1 error) {
	fake.setConfigOrderersMutex.Lock()
	defer fake.setConfigOrderersMutex.Unlock()
	fake.SetConfigOrderersStub = nil
	if fake.setConfigOrderersReturnsOnCall == nil {
		fake.setConfigOrderersReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setConfigOrderersReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ConfigProvider) TLSClientAuthRequired() bool {
	fake.tLSClientAuthRequiredMutex.Lock()
	ret, specificReturn := fake.tLSClientAuthRequiredReturnsOnCall[len(fake.tLSClientAuthRequiredArgsForCall)]
	fake.tLSClientAuthRequiredArgsForCall = append(fake.tLSClientAuthRequiredArgsForCall, struct {
	}{})
	stub := fake.TLSClientAuthRequiredStub
	fakeReturns := fake.tLSClientAuthRequiredReturns
	fake.recordInvocation("TLSClientAuthRequired", []interface{}{})
	fake.tLSClientAuthRequiredMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) TLSClientAuthRequiredCallCount() int {
	fake.tLSClientAuthRequiredMutex.RLock()
	defer fake.tLSClientAuthRequiredMutex.RUnlock()
	return len(fake.tLSClientAuthRequiredArgsForCall)
}

func (fake *ConfigProvider) TLSClientAuthRequiredCalls(stub func() bool) {
	fake.tLSClientAuthRequiredMutex.Lock()
	defer fake.tLSClientAuthRequiredMutex.Unlock()
	fake.TLSClientAuthRequiredStub = stub
}

func (fake *ConfigProvider) TLSClientAuthRequiredReturns(result1 bool) {
	fake.tLSClientAuthRequiredMutex.Lock()
	defer fake.tLSClientAuthRequiredMutex.Unlock()
	fake.TLSClientAuthRequiredStub = nil
	fake.tLSClientAuthRequiredReturns = struct {
		result1 bool
	}{result1}
}

func (fake *ConfigProvider) TLSClientAuthRequiredReturnsOnCall(i int, result1 bool) {
	fake.tLSClientAuthRequiredMutex.Lock()
	defer fake.tLSClientAuthRequiredMutex.Unlock()
	fake.TLSClientAuthRequiredStub = nil
	if fake.tLSClientAuthRequiredReturnsOnCall == nil {
		fake.tLSClientAuthRequiredReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.tLSClientAuthRequiredReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *ConfigProvider) TLSClientCertFile() string {
	fake.tLSClientCertFileMutex.Lock()
	ret, specificReturn := fake.tLSClientCertFileReturnsOnCall[len(fake.tLSClientCertFileArgsForCall)]
	fake.tLSClientCertFileArgsForCall = append(fake.tLSClientCertFileArgsForCall, struct {
	}{})
	stub := fake.TLSClientCertFileStub
	fakeReturns := fake.tLSClientCertFileReturns
	fake.recordInvocation("TLSClientCertFile", []interface{}{})
	fake.tLSClientCertFileMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) TLSClientCertFileCallCount() int {
	fake.tLSClientCertFileMutex.RLock()
	defer fake.tLSClientCertFileMutex.RUnlock()
	return len(fake.tLSClientCertFileArgsForCall)
}

func (fake *ConfigProvider) TLSClientCertFileCalls(stub func() string) {
	fake.tLSClientCertFileMutex.Lock()
	defer fake.tLSClientCertFileMutex.Unlock()
	fake.TLSClientCertFileStub = stub
}

func (fake *ConfigProvider) TLSClientCertFileReturns(result1 string) {
	fake.tLSClientCertFileMutex.Lock()
	defer fake.tLSClientCertFileMutex.Unlock()
	fake.TLSClientCertFileStub = nil
	fake.tLSClientCertFileReturns = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) TLSClientCertFileReturnsOnCall(i int, result1 string) {
	fake.tLSClientCertFileMutex.Lock()
	defer fake.tLSClientCertFileMutex.Unlock()
	fake.TLSClientCertFileStub = nil
	if fake.tLSClientCertFileReturnsOnCall == nil {
		fake.tLSClientCertFileReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.tLSClientCertFileReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) TLSClientKeyFile() string {
	fake.tLSClientKeyFileMutex.Lock()
	ret, specificReturn := fake.tLSClientKeyFileReturnsOnCall[len(fake.tLSClientKeyFileArgsForCall)]
	fake.tLSClientKeyFileArgsForCall = append(fake.tLSClientKeyFileArgsForCall, struct {
	}{})
	stub := fake.TLSClientKeyFileStub
	fakeReturns := fake.tLSClientKeyFileReturns
	fake.recordInvocation("TLSClientKeyFile", []interface{}{})
	fake.tLSClientKeyFileMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) TLSClientKeyFileCallCount() int {
	fake.tLSClientKeyFileMutex.RLock()
	defer fake.tLSClientKeyFileMutex.RUnlock()
	return len(fake.tLSClientKeyFileArgsForCall)
}

func (fake *ConfigProvider) TLSClientKeyFileCalls(stub func() string) {
	fake.tLSClientKeyFileMutex.Lock()
	defer fake.tLSClientKeyFileMutex.Unlock()
	fake.TLSClientKeyFileStub = stub
}

func (fake *ConfigProvider) TLSClientKeyFileReturns(result1 string) {
	fake.tLSClientKeyFileMutex.Lock()
	defer fake.tLSClientKeyFileMutex.Unlock()
	fake.TLSClientKeyFileStub = nil
	fake.tLSClientKeyFileReturns = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) TLSClientKeyFileReturnsOnCall(i int, result1 string) {
	fake.tLSClientKeyFileMutex.Lock()
	defer fake.tLSClientKeyFileMutex.Unlock()
	fake.TLSClientKeyFileStub = nil
	if fake.tLSClientKeyFileReturnsOnCall == nil {
		fake.tLSClientKeyFileReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.tLSClientKeyFileReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) TLSEnabled() bool {
	fake.tLSEnabledMutex.Lock()
	ret, specificReturn := fake.tLSEnabledReturnsOnCall[len(fake.tLSEnabledArgsForCall)]
	fake.tLSEnabledArgsForCall = append(fake.tLSEnabledArgsForCall, struct {
	}{})
	stub := fake.TLSEnabledStub
	fakeReturns := fake.tLSEnabledReturns
	fake.recordInvocation("TLSEnabled", []interface{}{})
	fake.tLSEnabledMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) TLSEnabledCallCount() int {
	fake.tLSEnabledMutex.RLock()
	defer fake.tLSEnabledMutex.RUnlock()
	return len(fake.tLSEnabledArgsForCall)
}

func (fake *ConfigProvider) TLSEnabledCalls(stub func() bool) {
	fake.tLSEnabledMutex.Lock()
	defer fake.tLSEnabledMutex.Unlock()
	fake.TLSEnabledStub = stub
}

func (fake *ConfigProvider) TLSEnabledReturns(result1 bool) {
	fake.tLSEnabledMutex.Lock()
	defer fake.tLSEnabledMutex.Unlock()
	fake.TLSEnabledStub = nil
	fake.tLSEnabledReturns = struct {
		result1 bool
	}{result1}
}

func (fake *ConfigProvider) TLSEnabledReturnsOnCall(i int, result1 bool) {
	fake.tLSEnabledMutex.Lock()
	defer fake.tLSEnabledMutex.Unlock()
	fake.TLSEnabledStub = nil
	if fake.tLSEnabledReturnsOnCall == nil {
		fake.tLSEnabledReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.tLSEnabledReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *ConfigProvider) TLSServerHostOverride() string {
	fake.tLSServerHostOverrideMutex.Lock()
	ret, specificReturn := fake.tLSServerHostOverrideReturnsOnCall[len(fake.tLSServerHostOverrideArgsForCall)]
	fake.tLSServerHostOverrideArgsForCall = append(fake.tLSServerHostOverrideArgsForCall, struct {
	}{})
	stub := fake.TLSServerHostOverrideStub
	fakeReturns := fake.tLSServerHostOverrideReturns
	fake.recordInvocation("TLSServerHostOverride", []interface{}{})
	fake.tLSServerHostOverrideMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) TLSServerHostOverrideCallCount() int {
	fake.tLSServerHostOverrideMutex.RLock()
	defer fake.tLSServerHostOverrideMutex.RUnlock()
	return len(fake.tLSServerHostOverrideArgsForCall)
}

func (fake *ConfigProvider) TLSServerHostOverrideCalls(stub func() string) {
	fake.tLSServerHostOverrideMutex.Lock()
	defer fake.tLSServerHostOverrideMutex.Unlock()
	fake.TLSServerHostOverrideStub = stub
}

func (fake *ConfigProvider) TLSServerHostOverrideReturns(result1 string) {
	fake.tLSServerHostOverrideMutex.Lock()
	defer fake.tLSServerHostOverrideMutex.Unlock()
	fake.TLSServerHostOverrideStub = nil
	fake.tLSServerHostOverrideReturns = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) TLSServerHostOverrideReturnsOnCall(i int, result1 string) {
	fake.tLSServerHostOverrideMutex.Lock()
	defer fake.tLSServerHostOverrideMutex.Unlock()
	fake.TLSServerHostOverrideStub = nil
	if fake.tLSServerHostOverrideReturnsOnCall == nil {
		fake.tLSServerHostOverrideReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.tLSServerHostOverrideReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) TranslatePath(arg1 string) string {
	fake.translatePathMutex.Lock()
	ret, specificReturn := fake.translatePathReturnsOnCall[len(fake.translatePathArgsForCall)]
	fake.translatePathArgsForCall = append(fake.translatePathArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.TranslatePathStub
	fakeReturns := fake.translatePathReturns
	fake.recordInvocation("TranslatePath", []interface{}{arg1})
	fake.translatePathMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) TranslatePathCallCount() int {
	fake.translatePathMutex.RLock()
	defer fake.translatePathMutex.RUnlock()
	return len(fake.translatePathArgsForCall)
}

func (fake *ConfigProvider) TranslatePathCalls(stub func(string) string) {
	fake.translatePathMutex.Lock()
	defer fake.translatePathMutex.Unlock()
	fake.TranslatePathStub = stub
}

func (fake *ConfigProvider) TranslatePathArgsForCall(i int) string {
	fake.translatePathMutex.RLock()
	defer fake.translatePathMutex.RUnlock()
	argsForCall := fake.translatePathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ConfigProvider) TranslatePathReturns(result1 string) {
	fake.translatePathMutex.Lock()
	defer fake.translatePathMutex.Unlock()
	fake.TranslatePathStub = nil
	fake.translatePathReturns = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) TranslatePathReturnsOnCall(i int, result1 string) {
	fake.translatePathMutex.Lock()
	defer fake.translatePathMutex.Unlock()
	fake.TranslatePathStub = nil
	if fake.translatePathReturnsOnCall == nil {
		fake.translatePathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.translatePathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) UnmarshalKey(arg1 string, arg2 interface{}) error {
	fake.unmarshalKeyMutex.Lock()
	ret, specificReturn := fake.unmarshalKeyReturnsOnCall[len(fake.unmarshalKeyArgsForCall)]
	fake.unmarshalKeyArgsForCall = append(fake.unmarshalKeyArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.UnmarshalKeyStub
	fakeReturns := fake.unmarshalKeyReturns
	fake.recordInvocation("UnmarshalKey", []interface{}{arg1, arg2})
	fake.unmarshalKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) UnmarshalKeyCallCount() int {
	fake.unmarshalKeyMutex.RLock()
	defer fake.unmarshalKeyMutex.RUnlock()
	return len(fake.unmarshalKeyArgsForCall)
}

func (fake *ConfigProvider) UnmarshalKeyCalls(stub func(string, interface{}) error) {
	fake.unmarshalKeyMutex.Lock()
	defer fake.unmarshalKeyMutex.Unlock()
	fake.UnmarshalKeyStub = stub
}

func (fake *ConfigProvider) UnmarshalKeyArgsForCall(i int) (string, interface{}) {
	fake.unmarshalKeyMutex.RLock()
	defer fake.unmarshalKeyMutex.RUnlock()
	argsForCall := fake.unmarshalKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ConfigProvider) UnmarshalKeyReturns(result1 error) {
	fake.unmarshalKeyMutex.Lock()
	defer fake.unmarshalKeyMutex.Unlock()
	fake.UnmarshalKeyStub = nil
	fake.unmarshalKeyReturns = struct {
		result1 error
	}{result1}
}

func (fake *ConfigProvider) UnmarshalKeyReturnsOnCall(i int, result1 error) {
	fake.unmarshalKeyMutex.Lock()
	defer fake.unmarshalKeyMutex.Unlock()
	fake.UnmarshalKeyStub = nil
	if fake.unmarshalKeyReturnsOnCall == nil {
		fake.unmarshalKeyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unmarshalKeyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ConfigProvider) VaultPersistencePrefix() string {
	fake.vaultPersistencePrefixMutex.Lock()
	ret, specificReturn := fake.vaultPersistencePrefixReturnsOnCall[len(fake.vaultPersistencePrefixArgsForCall)]
	fake.vaultPersistencePrefixArgsForCall = append(fake.vaultPersistencePrefixArgsForCall, struct {
	}{})
	stub := fake.VaultPersistencePrefixStub
	fakeReturns := fake.vaultPersistencePrefixReturns
	fake.recordInvocation("VaultPersistencePrefix", []interface{}{})
	fake.vaultPersistencePrefixMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) VaultPersistencePrefixCallCount() int {
	fake.vaultPersistencePrefixMutex.RLock()
	defer fake.vaultPersistencePrefixMutex.RUnlock()
	return len(fake.vaultPersistencePrefixArgsForCall)
}

func (fake *ConfigProvider) VaultPersistencePrefixCalls(stub func() string) {
	fake.vaultPersistencePrefixMutex.Lock()
	defer fake.vaultPersistencePrefixMutex.Unlock()
	fake.VaultPersistencePrefixStub = stub
}

func (fake *ConfigProvider) VaultPersistencePrefixReturns(result1 string) {
	fake.vaultPersistencePrefixMutex.Lock()
	defer fake.vaultPersistencePrefixMutex.Unlock()
	fake.VaultPersistencePrefixStub = nil
	fake.vaultPersistencePrefixReturns = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) VaultPersistencePrefixReturnsOnCall(i int, result1 string) {
	fake.vaultPersistencePrefixMutex.Lock()
	defer fake.vaultPersistencePrefixMutex.Unlock()
	fake.VaultPersistencePrefixStub = nil
	if fake.vaultPersistencePrefixReturnsOnCall == nil {
		fake.vaultPersistencePrefixReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.vaultPersistencePrefixReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ConfigProvider) VaultPersistenceType() driverb.PersistenceType {
	fake.vaultPersistenceTypeMutex.Lock()
	ret, specificReturn := fake.vaultPersistenceTypeReturnsOnCall[len(fake.vaultPersistenceTypeArgsForCall)]
	fake.vaultPersistenceTypeArgsForCall = append(fake.vaultPersistenceTypeArgsForCall, struct {
	}{})
	stub := fake.VaultPersistenceTypeStub
	fakeReturns := fake.vaultPersistenceTypeReturns
	fake.recordInvocation("VaultPersistenceType", []interface{}{})
	fake.vaultPersistenceTypeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) VaultPersistenceTypeCallCount() int {
	fake.vaultPersistenceTypeMutex.RLock()
	defer fake.vaultPersistenceTypeMutex.RUnlock()
	return len(fake.vaultPersistenceTypeArgsForCall)
}

func (fake *ConfigProvider) VaultPersistenceTypeCalls(stub func() driverb.PersistenceType) {
	fake.vaultPersistenceTypeMutex.Lock()
	defer fake.vaultPersistenceTypeMutex.Unlock()
	fake.VaultPersistenceTypeStub = stub
}

func (fake *ConfigProvider) VaultPersistenceTypeReturns(result1 driverb.PersistenceType) {
	fake.vaultPersistenceTypeMutex.Lock()
	defer fake.vaultPersistenceTypeMutex.Unlock()
	fake.VaultPersistenceTypeStub = nil
	fake.vaultPersistenceTypeReturns = struct {
		result1 driverb.PersistenceType
	}{result1}
}

func (fake *ConfigProvider) VaultPersistenceTypeReturnsOnCall(i int, result1 driverb.PersistenceType) {
	fake.vaultPersistenceTypeMutex.Lock()
	defer fake.vaultPersistenceTypeMutex.Unlock()
	fake.VaultPersistenceTypeStub = nil
	if fake.vaultPersistenceTypeReturnsOnCall == nil {
		fake.vaultPersistenceTypeReturnsOnCall = make(map[int]struct {
			result1 driverb.PersistenceType
		})
	}
	fake.vaultPersistenceTypeReturnsOnCall[i] = struct {
		result1 driverb.PersistenceType
	}{result1}
}

func (fake *ConfigProvider) VaultTXStoreCacheSize() int {
	fake.vaultTXStoreCacheSizeMutex.Lock()
	ret, specificReturn := fake.vaultTXStoreCacheSizeReturnsOnCall[len(fake.vaultTXStoreCacheSizeArgsForCall)]
	fake.vaultTXStoreCacheSizeArgsForCall = append(fake.vaultTXStoreCacheSizeArgsForCall, struct {
	}{})
	stub := fake.VaultTXStoreCacheSizeStub
	fakeReturns := fake.vaultTXStoreCacheSizeReturns
	fake.recordInvocation("VaultTXStoreCacheSize", []interface{}{})
	fake.vaultTXStoreCacheSizeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ConfigProvider) VaultTXStoreCacheSizeCallCount() int {
	fake.vaultTXStoreCacheSizeMutex.RLock()
	defer fake.vaultTXStoreCacheSizeMutex.RUnlock()
	return len(fake.vaultTXStoreCacheSizeArgsForCall)
}

func (fake *ConfigProvider) VaultTXStoreCacheSizeCalls(stub func() int) {
	fake.vaultTXStoreCacheSizeMutex.Lock()
	defer fake.vaultTXStoreCacheSizeMutex.Unlock()
	fake.VaultTXStoreCacheSizeStub = stub
}

func (fake *ConfigProvider) VaultTXStoreCacheSizeReturns(result1 int) {
	fake.vaultTXStoreCacheSizeMutex.Lock()
	defer fake.vaultTXStoreCacheSizeMutex.Unlock()
	fake.VaultTXStoreCacheSizeStub = nil
	fake.vaultTXStoreCacheSizeReturns = struct {
		result1 int
	}{result1}
}

func (fake *ConfigProvider) VaultTXStoreCacheSizeReturnsOnCall(i int, result1 int) {
	fake.vaultTXStoreCacheSizeMutex.Lock()
	defer fake.vaultTXStoreCacheSizeMutex.Unlock()
	fake.VaultTXStoreCacheSizeStub = nil
	if fake.vaultTXStoreCacheSizeReturnsOnCall == nil {
		fake.vaultTXStoreCacheSizeReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.vaultTXStoreCacheSizeReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *ConfigProvider) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.broadcastNumRetriesMutex.RLock()
	defer fake.broadcastNumRetriesMutex.RUnlock()
	fake.broadcastRetryIntervalMutex.RLock()
	defer fake.broadcastRetryIntervalMutex.RUnlock()
	fake.channelMutex.RLock()
	defer fake.channelMutex.RUnlock()
	fake.channelIDsMutex.RLock()
	defer fake.channelIDsMutex.RUnlock()
	fake.clientConnTimeoutMutex.RLock()
	defer fake.clientConnTimeoutMutex.RUnlock()
	fake.configFileUsedMutex.RLock()
	defer fake.configFileUsedMutex.RUnlock()
	fake.defaultChannelMutex.RLock()
	defer fake.defaultChannelMutex.RUnlock()
	fake.getBoolMutex.RLock()
	defer fake.getBoolMutex.RUnlock()
	fake.getDurationMutex.RLock()
	defer fake.getDurationMutex.RUnlock()
	fake.getIntMutex.RLock()
	defer fake.getIntMutex.RUnlock()
	fake.getPathMutex.RLock()
	defer fake.getPathMutex.RUnlock()
	fake.getStringMutex.RLock()
	defer fake.getStringMutex.RUnlock()
	fake.getStringSliceMutex.RLock()
	defer fake.getStringSliceMutex.RUnlock()
	fake.isChannelQuietMutex.RLock()
	defer fake.isChannelQuietMutex.RUnlock()
	fake.isSetMutex.RLock()
	defer fake.isSetMutex.RUnlock()
	fake.keepAliveClientIntervalMutex.RLock()
	defer fake.keepAliveClientIntervalMutex.RUnlock()
	fake.keepAliveClientTimeoutMutex.RLock()
	defer fake.keepAliveClientTimeoutMutex.RUnlock()
	fake.networkNameMutex.RLock()
	defer fake.networkNameMutex.RUnlock()
	fake.newDefaultChannelConfigMutex.RLock()
	defer fake.newDefaultChannelConfigMutex.RUnlock()
	fake.ordererConnectionPoolSizeMutex.RLock()
	defer fake.ordererConnectionPoolSizeMutex.RUnlock()
	fake.orderersMutex.RLock()
	defer fake.orderersMutex.RUnlock()
	fake.pickOrdererMutex.RLock()
	defer fake.pickOrdererMutex.RUnlock()
	fake.pickPeerMutex.RLock()
	defer fake.pickPeerMutex.RUnlock()
	fake.setConfigOrderersMutex.RLock()
	defer fake.setConfigOrderersMutex.RUnlock()
	fake.tLSClientAuthRequiredMutex.RLock()
	defer fake.tLSClientAuthRequiredMutex.RUnlock()
	fake.tLSClientCertFileMutex.RLock()
	defer fake.tLSClientCertFileMutex.RUnlock()
	fake.tLSClientKeyFileMutex.RLock()
	defer fake.tLSClientKeyFileMutex.RUnlock()
	fake.tLSEnabledMutex.RLock()
	defer fake.tLSEnabledMutex.RUnlock()
	fake.tLSServerHostOverrideMutex.RLock()
	defer fake.tLSServerHostOverrideMutex.RUnlock()
	fake.translatePathMutex.RLock()
	defer fake.translatePathMutex.RUnlock()
	fake.unmarshalKeyMutex.RLock()
	defer fake.unmarshalKeyMutex.RUnlock()
	fake.vaultPersistencePrefixMutex.RLock()
	defer fake.vaultPersistencePrefixMutex.RUnlock()
	fake.vaultPersistenceTypeMutex.RLock()
	defer fake.vaultPersistenceTypeMutex.RUnlock()
	fake.vaultTXStoreCacheSizeMutex.RLock()
	defer fake.vaultTXStoreCacheSizeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ConfigProvider) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ driver.ConfigProvider = new(ConfigProvider)
