// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"context"
	"sync"

	"github.com/hyperledger-labs/fabric-smart-client/platform/view/services/view"
	viewa "github.com/hyperledger-labs/fabric-smart-client/platform/view/view"
	"go.opentelemetry.io/otel/trace"
)

type ParentContext struct {
	CleanupStub        func()
	cleanupMutex       sync.RWMutex
	cleanupArgsForCall []struct {
	}
	ContextStub        func() context.Context
	contextMutex       sync.RWMutex
	contextArgsForCall []struct {
	}
	contextReturns struct {
		result1 context.Context
	}
	contextReturnsOnCall map[int]struct {
		result1 context.Context
	}
	DisposeStub        func()
	disposeMutex       sync.RWMutex
	disposeArgsForCall []struct {
	}
	GetServiceStub        func(interface{}) (interface{}, error)
	getServiceMutex       sync.RWMutex
	getServiceArgsForCall []struct {
		arg1 interface{}
	}
	getServiceReturns struct {
		result1 interface{}
		result2 error
	}
	getServiceReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	GetSessionStub        func(viewa.View, viewa.Identity, ...viewa.View) (viewa.Session, error)
	getSessionMutex       sync.RWMutex
	getSessionArgsForCall []struct {
		arg1 viewa.View
		arg2 viewa.Identity
		arg3 []viewa.View
	}
	getSessionReturns struct {
		result1 viewa.Session
		result2 error
	}
	getSessionReturnsOnCall map[int]struct {
		result1 viewa.Session
		result2 error
	}
	GetSessionByIDStub        func(string, viewa.Identity) (viewa.Session, error)
	getSessionByIDMutex       sync.RWMutex
	getSessionByIDArgsForCall []struct {
		arg1 string
		arg2 viewa.Identity
	}
	getSessionByIDReturns struct {
		result1 viewa.Session
		result2 error
	}
	getSessionByIDReturnsOnCall map[int]struct {
		result1 viewa.Session
		result2 error
	}
	IDStub        func() string
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 string
	}
	iDReturnsOnCall map[int]struct {
		result1 string
	}
	InitiatorStub        func() viewa.View
	initiatorMutex       sync.RWMutex
	initiatorArgsForCall []struct {
	}
	initiatorReturns struct {
		result1 viewa.View
	}
	initiatorReturnsOnCall map[int]struct {
		result1 viewa.View
	}
	IsMeStub        func(viewa.Identity) bool
	isMeMutex       sync.RWMutex
	isMeArgsForCall []struct {
		arg1 viewa.Identity
	}
	isMeReturns struct {
		result1 bool
	}
	isMeReturnsOnCall map[int]struct {
		result1 bool
	}
	MeStub        func() viewa.Identity
	meMutex       sync.RWMutex
	meArgsForCall []struct {
	}
	meReturns struct {
		result1 viewa.Identity
	}
	meReturnsOnCall map[int]struct {
		result1 viewa.Identity
	}
	OnErrorStub        func(func())
	onErrorMutex       sync.RWMutex
	onErrorArgsForCall []struct {
		arg1 func()
	}
	PutSessionStub        func(viewa.View, viewa.Identity, viewa.Session) error
	putSessionMutex       sync.RWMutex
	putSessionArgsForCall []struct {
		arg1 viewa.View
		arg2 viewa.Identity
		arg3 viewa.Session
	}
	putSessionReturns struct {
		result1 error
	}
	putSessionReturnsOnCall map[int]struct {
		result1 error
	}
	RunViewStub        func(viewa.View, ...viewa.RunViewOption) (interface{}, error)
	runViewMutex       sync.RWMutex
	runViewArgsForCall []struct {
		arg1 viewa.View
		arg2 []viewa.RunViewOption
	}
	runViewReturns struct {
		result1 interface{}
		result2 error
	}
	runViewReturnsOnCall map[int]struct {
		result1 interface{}
		result2 error
	}
	SessionStub        func() viewa.Session
	sessionMutex       sync.RWMutex
	sessionArgsForCall []struct {
	}
	sessionReturns struct {
		result1 viewa.Session
	}
	sessionReturnsOnCall map[int]struct {
		result1 viewa.Session
	}
	StartSpanFromStub        func(context.Context, string, ...trace.SpanStartOption) (context.Context, trace.Span)
	startSpanFromMutex       sync.RWMutex
	startSpanFromArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []trace.SpanStartOption
	}
	startSpanFromReturns struct {
		result1 context.Context
		result2 trace.Span
	}
	startSpanFromReturnsOnCall map[int]struct {
		result1 context.Context
		result2 trace.Span
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ParentContext) Cleanup() {
	fake.cleanupMutex.Lock()
	fake.cleanupArgsForCall = append(fake.cleanupArgsForCall, struct {
	}{})
	stub := fake.CleanupStub
	fake.recordInvocation("Cleanup", []interface{}{})
	fake.cleanupMutex.Unlock()
	if stub != nil {
		fake.CleanupStub()
	}
}

func (fake *ParentContext) CleanupCallCount() int {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	return len(fake.cleanupArgsForCall)
}

func (fake *ParentContext) CleanupCalls(stub func()) {
	fake.cleanupMutex.Lock()
	defer fake.cleanupMutex.Unlock()
	fake.CleanupStub = stub
}

func (fake *ParentContext) Context() context.Context {
	fake.contextMutex.Lock()
	ret, specificReturn := fake.contextReturnsOnCall[len(fake.contextArgsForCall)]
	fake.contextArgsForCall = append(fake.contextArgsForCall, struct {
	}{})
	stub := fake.ContextStub
	fakeReturns := fake.contextReturns
	fake.recordInvocation("Context", []interface{}{})
	fake.contextMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ParentContext) ContextCallCount() int {
	fake.contextMutex.RLock()
	defer fake.contextMutex.RUnlock()
	return len(fake.contextArgsForCall)
}

func (fake *ParentContext) ContextCalls(stub func() context.Context) {
	fake.contextMutex.Lock()
	defer fake.contextMutex.Unlock()
	fake.ContextStub = stub
}

func (fake *ParentContext) ContextReturns(result1 context.Context) {
	fake.contextMutex.Lock()
	defer fake.contextMutex.Unlock()
	fake.ContextStub = nil
	fake.contextReturns = struct {
		result1 context.Context
	}{result1}
}

func (fake *ParentContext) ContextReturnsOnCall(i int, result1 context.Context) {
	fake.contextMutex.Lock()
	defer fake.contextMutex.Unlock()
	fake.ContextStub = nil
	if fake.contextReturnsOnCall == nil {
		fake.contextReturnsOnCall = make(map[int]struct {
			result1 context.Context
		})
	}
	fake.contextReturnsOnCall[i] = struct {
		result1 context.Context
	}{result1}
}

func (fake *ParentContext) Dispose() {
	fake.disposeMutex.Lock()
	fake.disposeArgsForCall = append(fake.disposeArgsForCall, struct {
	}{})
	stub := fake.DisposeStub
	fake.recordInvocation("Dispose", []interface{}{})
	fake.disposeMutex.Unlock()
	if stub != nil {
		fake.DisposeStub()
	}
}

func (fake *ParentContext) DisposeCallCount() int {
	fake.disposeMutex.RLock()
	defer fake.disposeMutex.RUnlock()
	return len(fake.disposeArgsForCall)
}

func (fake *ParentContext) DisposeCalls(stub func()) {
	fake.disposeMutex.Lock()
	defer fake.disposeMutex.Unlock()
	fake.DisposeStub = stub
}

func (fake *ParentContext) GetService(arg1 interface{}) (interface{}, error) {
	fake.getServiceMutex.Lock()
	ret, specificReturn := fake.getServiceReturnsOnCall[len(fake.getServiceArgsForCall)]
	fake.getServiceArgsForCall = append(fake.getServiceArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	stub := fake.GetServiceStub
	fakeReturns := fake.getServiceReturns
	fake.recordInvocation("GetService", []interface{}{arg1})
	fake.getServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ParentContext) GetServiceCallCount() int {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	return len(fake.getServiceArgsForCall)
}

func (fake *ParentContext) GetServiceCalls(stub func(interface{}) (interface{}, error)) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = stub
}

func (fake *ParentContext) GetServiceArgsForCall(i int) interface{} {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	argsForCall := fake.getServiceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ParentContext) GetServiceReturns(result1 interface{}, result2 error) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = nil
	fake.getServiceReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *ParentContext) GetServiceReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.getServiceMutex.Lock()
	defer fake.getServiceMutex.Unlock()
	fake.GetServiceStub = nil
	if fake.getServiceReturnsOnCall == nil {
		fake.getServiceReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.getServiceReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *ParentContext) GetSession(arg1 viewa.View, arg2 viewa.Identity, arg3 ...viewa.View) (viewa.Session, error) {
	fake.getSessionMutex.Lock()
	ret, specificReturn := fake.getSessionReturnsOnCall[len(fake.getSessionArgsForCall)]
	fake.getSessionArgsForCall = append(fake.getSessionArgsForCall, struct {
		arg1 viewa.View
		arg2 viewa.Identity
		arg3 []viewa.View
	}{arg1, arg2, arg3})
	stub := fake.GetSessionStub
	fakeReturns := fake.getSessionReturns
	fake.recordInvocation("GetSession", []interface{}{arg1, arg2, arg3})
	fake.getSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ParentContext) GetSessionCallCount() int {
	fake.getSessionMutex.RLock()
	defer fake.getSessionMutex.RUnlock()
	return len(fake.getSessionArgsForCall)
}

func (fake *ParentContext) GetSessionCalls(stub func(viewa.View, viewa.Identity, ...viewa.View) (viewa.Session, error)) {
	fake.getSessionMutex.Lock()
	defer fake.getSessionMutex.Unlock()
	fake.GetSessionStub = stub
}

func (fake *ParentContext) GetSessionArgsForCall(i int) (viewa.View, viewa.Identity, []viewa.View) {
	fake.getSessionMutex.RLock()
	defer fake.getSessionMutex.RUnlock()
	argsForCall := fake.getSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *ParentContext) GetSessionReturns(result1 viewa.Session, result2 error) {
	fake.getSessionMutex.Lock()
	defer fake.getSessionMutex.Unlock()
	fake.GetSessionStub = nil
	fake.getSessionReturns = struct {
		result1 viewa.Session
		result2 error
	}{result1, result2}
}

func (fake *ParentContext) GetSessionReturnsOnCall(i int, result1 viewa.Session, result2 error) {
	fake.getSessionMutex.Lock()
	defer fake.getSessionMutex.Unlock()
	fake.GetSessionStub = nil
	if fake.getSessionReturnsOnCall == nil {
		fake.getSessionReturnsOnCall = make(map[int]struct {
			result1 viewa.Session
			result2 error
		})
	}
	fake.getSessionReturnsOnCall[i] = struct {
		result1 viewa.Session
		result2 error
	}{result1, result2}
}

func (fake *ParentContext) GetSessionByID(arg1 string, arg2 viewa.Identity) (viewa.Session, error) {
	fake.getSessionByIDMutex.Lock()
	ret, specificReturn := fake.getSessionByIDReturnsOnCall[len(fake.getSessionByIDArgsForCall)]
	fake.getSessionByIDArgsForCall = append(fake.getSessionByIDArgsForCall, struct {
		arg1 string
		arg2 viewa.Identity
	}{arg1, arg2})
	stub := fake.GetSessionByIDStub
	fakeReturns := fake.getSessionByIDReturns
	fake.recordInvocation("GetSessionByID", []interface{}{arg1, arg2})
	fake.getSessionByIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ParentContext) GetSessionByIDCallCount() int {
	fake.getSessionByIDMutex.RLock()
	defer fake.getSessionByIDMutex.RUnlock()
	return len(fake.getSessionByIDArgsForCall)
}

func (fake *ParentContext) GetSessionByIDCalls(stub func(string, viewa.Identity) (viewa.Session, error)) {
	fake.getSessionByIDMutex.Lock()
	defer fake.getSessionByIDMutex.Unlock()
	fake.GetSessionByIDStub = stub
}

func (fake *ParentContext) GetSessionByIDArgsForCall(i int) (string, viewa.Identity) {
	fake.getSessionByIDMutex.RLock()
	defer fake.getSessionByIDMutex.RUnlock()
	argsForCall := fake.getSessionByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ParentContext) GetSessionByIDReturns(result1 viewa.Session, result2 error) {
	fake.getSessionByIDMutex.Lock()
	defer fake.getSessionByIDMutex.Unlock()
	fake.GetSessionByIDStub = nil
	fake.getSessionByIDReturns = struct {
		result1 viewa.Session
		result2 error
	}{result1, result2}
}

func (fake *ParentContext) GetSessionByIDReturnsOnCall(i int, result1 viewa.Session, result2 error) {
	fake.getSessionByIDMutex.Lock()
	defer fake.getSessionByIDMutex.Unlock()
	fake.GetSessionByIDStub = nil
	if fake.getSessionByIDReturnsOnCall == nil {
		fake.getSessionByIDReturnsOnCall = make(map[int]struct {
			result1 viewa.Session
			result2 error
		})
	}
	fake.getSessionByIDReturnsOnCall[i] = struct {
		result1 viewa.Session
		result2 error
	}{result1, result2}
}

func (fake *ParentContext) ID() string {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ParentContext) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *ParentContext) IDCalls(stub func() string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *ParentContext) IDReturns(result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 string
	}{result1}
}

func (fake *ParentContext) IDReturnsOnCall(i int, result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *ParentContext) Initiator() viewa.View {
	fake.initiatorMutex.Lock()
	ret, specificReturn := fake.initiatorReturnsOnCall[len(fake.initiatorArgsForCall)]
	fake.initiatorArgsForCall = append(fake.initiatorArgsForCall, struct {
	}{})
	stub := fake.InitiatorStub
	fakeReturns := fake.initiatorReturns
	fake.recordInvocation("Initiator", []interface{}{})
	fake.initiatorMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ParentContext) InitiatorCallCount() int {
	fake.initiatorMutex.RLock()
	defer fake.initiatorMutex.RUnlock()
	return len(fake.initiatorArgsForCall)
}

func (fake *ParentContext) InitiatorCalls(stub func() viewa.View) {
	fake.initiatorMutex.Lock()
	defer fake.initiatorMutex.Unlock()
	fake.InitiatorStub = stub
}

func (fake *ParentContext) InitiatorReturns(result1 viewa.View) {
	fake.initiatorMutex.Lock()
	defer fake.initiatorMutex.Unlock()
	fake.InitiatorStub = nil
	fake.initiatorReturns = struct {
		result1 viewa.View
	}{result1}
}

func (fake *ParentContext) InitiatorReturnsOnCall(i int, result1 viewa.View) {
	fake.initiatorMutex.Lock()
	defer fake.initiatorMutex.Unlock()
	fake.InitiatorStub = nil
	if fake.initiatorReturnsOnCall == nil {
		fake.initiatorReturnsOnCall = make(map[int]struct {
			result1 viewa.View
		})
	}
	fake.initiatorReturnsOnCall[i] = struct {
		result1 viewa.View
	}{result1}
}

func (fake *ParentContext) IsMe(arg1 viewa.Identity) bool {
	fake.isMeMutex.Lock()
	ret, specificReturn := fake.isMeReturnsOnCall[len(fake.isMeArgsForCall)]
	fake.isMeArgsForCall = append(fake.isMeArgsForCall, struct {
		arg1 viewa.Identity
	}{arg1})
	stub := fake.IsMeStub
	fakeReturns := fake.isMeReturns
	fake.recordInvocation("IsMe", []interface{}{arg1})
	fake.isMeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ParentContext) IsMeCallCount() int {
	fake.isMeMutex.RLock()
	defer fake.isMeMutex.RUnlock()
	return len(fake.isMeArgsForCall)
}

func (fake *ParentContext) IsMeCalls(stub func(viewa.Identity) bool) {
	fake.isMeMutex.Lock()
	defer fake.isMeMutex.Unlock()
	fake.IsMeStub = stub
}

func (fake *ParentContext) IsMeArgsForCall(i int) viewa.Identity {
	fake.isMeMutex.RLock()
	defer fake.isMeMutex.RUnlock()
	argsForCall := fake.isMeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ParentContext) IsMeReturns(result1 bool) {
	fake.isMeMutex.Lock()
	defer fake.isMeMutex.Unlock()
	fake.IsMeStub = nil
	fake.isMeReturns = struct {
		result1 bool
	}{result1}
}

func (fake *ParentContext) IsMeReturnsOnCall(i int, result1 bool) {
	fake.isMeMutex.Lock()
	defer fake.isMeMutex.Unlock()
	fake.IsMeStub = nil
	if fake.isMeReturnsOnCall == nil {
		fake.isMeReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isMeReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *ParentContext) Me() viewa.Identity {
	fake.meMutex.Lock()
	ret, specificReturn := fake.meReturnsOnCall[len(fake.meArgsForCall)]
	fake.meArgsForCall = append(fake.meArgsForCall, struct {
	}{})
	stub := fake.MeStub
	fakeReturns := fake.meReturns
	fake.recordInvocation("Me", []interface{}{})
	fake.meMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ParentContext) MeCallCount() int {
	fake.meMutex.RLock()
	defer fake.meMutex.RUnlock()
	return len(fake.meArgsForCall)
}

func (fake *ParentContext) MeCalls(stub func() viewa.Identity) {
	fake.meMutex.Lock()
	defer fake.meMutex.Unlock()
	fake.MeStub = stub
}

func (fake *ParentContext) MeReturns(result1 viewa.Identity) {
	fake.meMutex.Lock()
	defer fake.meMutex.Unlock()
	fake.MeStub = nil
	fake.meReturns = struct {
		result1 viewa.Identity
	}{result1}
}

func (fake *ParentContext) MeReturnsOnCall(i int, result1 viewa.Identity) {
	fake.meMutex.Lock()
	defer fake.meMutex.Unlock()
	fake.MeStub = nil
	if fake.meReturnsOnCall == nil {
		fake.meReturnsOnCall = make(map[int]struct {
			result1 viewa.Identity
		})
	}
	fake.meReturnsOnCall[i] = struct {
		result1 viewa.Identity
	}{result1}
}

func (fake *ParentContext) OnError(arg1 func()) {
	fake.onErrorMutex.Lock()
	fake.onErrorArgsForCall = append(fake.onErrorArgsForCall, struct {
		arg1 func()
	}{arg1})
	stub := fake.OnErrorStub
	fake.recordInvocation("OnError", []interface{}{arg1})
	fake.onErrorMutex.Unlock()
	if stub != nil {
		fake.OnErrorStub(arg1)
	}
}

func (fake *ParentContext) OnErrorCallCount() int {
	fake.onErrorMutex.RLock()
	defer fake.onErrorMutex.RUnlock()
	return len(fake.onErrorArgsForCall)
}

func (fake *ParentContext) OnErrorCalls(stub func(func())) {
	fake.onErrorMutex.Lock()
	defer fake.onErrorMutex.Unlock()
	fake.OnErrorStub = stub
}

func (fake *ParentContext) OnErrorArgsForCall(i int) func() {
	fake.onErrorMutex.RLock()
	defer fake.onErrorMutex.RUnlock()
	argsForCall := fake.onErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ParentContext) PutSession(arg1 viewa.View, arg2 viewa.Identity, arg3 viewa.Session) error {
	fake.putSessionMutex.Lock()
	ret, specificReturn := fake.putSessionReturnsOnCall[len(fake.putSessionArgsForCall)]
	fake.putSessionArgsForCall = append(fake.putSessionArgsForCall, struct {
		arg1 viewa.View
		arg2 viewa.Identity
		arg3 viewa.Session
	}{arg1, arg2, arg3})
	stub := fake.PutSessionStub
	fakeReturns := fake.putSessionReturns
	fake.recordInvocation("PutSession", []interface{}{arg1, arg2, arg3})
	fake.putSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ParentContext) PutSessionCallCount() int {
	fake.putSessionMutex.RLock()
	defer fake.putSessionMutex.RUnlock()
	return len(fake.putSessionArgsForCall)
}

func (fake *ParentContext) PutSessionCalls(stub func(viewa.View, viewa.Identity, viewa.Session) error) {
	fake.putSessionMutex.Lock()
	defer fake.putSessionMutex.Unlock()
	fake.PutSessionStub = stub
}

func (fake *ParentContext) PutSessionArgsForCall(i int) (viewa.View, viewa.Identity, viewa.Session) {
	fake.putSessionMutex.RLock()
	defer fake.putSessionMutex.RUnlock()
	argsForCall := fake.putSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *ParentContext) PutSessionReturns(result1 error) {
	fake.putSessionMutex.Lock()
	defer fake.putSessionMutex.Unlock()
	fake.PutSessionStub = nil
	fake.putSessionReturns = struct {
		result1 error
	}{result1}
}

func (fake *ParentContext) PutSessionReturnsOnCall(i int, result1 error) {
	fake.putSessionMutex.Lock()
	defer fake.putSessionMutex.Unlock()
	fake.PutSessionStub = nil
	if fake.putSessionReturnsOnCall == nil {
		fake.putSessionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.putSessionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ParentContext) RunView(arg1 viewa.View, arg2 ...viewa.RunViewOption) (interface{}, error) {
	fake.runViewMutex.Lock()
	ret, specificReturn := fake.runViewReturnsOnCall[len(fake.runViewArgsForCall)]
	fake.runViewArgsForCall = append(fake.runViewArgsForCall, struct {
		arg1 viewa.View
		arg2 []viewa.RunViewOption
	}{arg1, arg2})
	stub := fake.RunViewStub
	fakeReturns := fake.runViewReturns
	fake.recordInvocation("RunView", []interface{}{arg1, arg2})
	fake.runViewMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ParentContext) RunViewCallCount() int {
	fake.runViewMutex.RLock()
	defer fake.runViewMutex.RUnlock()
	return len(fake.runViewArgsForCall)
}

func (fake *ParentContext) RunViewCalls(stub func(viewa.View, ...viewa.RunViewOption) (interface{}, error)) {
	fake.runViewMutex.Lock()
	defer fake.runViewMutex.Unlock()
	fake.RunViewStub = stub
}

func (fake *ParentContext) RunViewArgsForCall(i int) (viewa.View, []viewa.RunViewOption) {
	fake.runViewMutex.RLock()
	defer fake.runViewMutex.RUnlock()
	argsForCall := fake.runViewArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ParentContext) RunViewReturns(result1 interface{}, result2 error) {
	fake.runViewMutex.Lock()
	defer fake.runViewMutex.Unlock()
	fake.RunViewStub = nil
	fake.runViewReturns = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *ParentContext) RunViewReturnsOnCall(i int, result1 interface{}, result2 error) {
	fake.runViewMutex.Lock()
	defer fake.runViewMutex.Unlock()
	fake.RunViewStub = nil
	if fake.runViewReturnsOnCall == nil {
		fake.runViewReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 error
		})
	}
	fake.runViewReturnsOnCall[i] = struct {
		result1 interface{}
		result2 error
	}{result1, result2}
}

func (fake *ParentContext) Session() viewa.Session {
	fake.sessionMutex.Lock()
	ret, specificReturn := fake.sessionReturnsOnCall[len(fake.sessionArgsForCall)]
	fake.sessionArgsForCall = append(fake.sessionArgsForCall, struct {
	}{})
	stub := fake.SessionStub
	fakeReturns := fake.sessionReturns
	fake.recordInvocation("Session", []interface{}{})
	fake.sessionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ParentContext) SessionCallCount() int {
	fake.sessionMutex.RLock()
	defer fake.sessionMutex.RUnlock()
	return len(fake.sessionArgsForCall)
}

func (fake *ParentContext) SessionCalls(stub func() viewa.Session) {
	fake.sessionMutex.Lock()
	defer fake.sessionMutex.Unlock()
	fake.SessionStub = stub
}

func (fake *ParentContext) SessionReturns(result1 viewa.Session) {
	fake.sessionMutex.Lock()
	defer fake.sessionMutex.Unlock()
	fake.SessionStub = nil
	fake.sessionReturns = struct {
		result1 viewa.Session
	}{result1}
}

func (fake *ParentContext) SessionReturnsOnCall(i int, result1 viewa.Session) {
	fake.sessionMutex.Lock()
	defer fake.sessionMutex.Unlock()
	fake.SessionStub = nil
	if fake.sessionReturnsOnCall == nil {
		fake.sessionReturnsOnCall = make(map[int]struct {
			result1 viewa.Session
		})
	}
	fake.sessionReturnsOnCall[i] = struct {
		result1 viewa.Session
	}{result1}
}

func (fake *ParentContext) StartSpanFrom(arg1 context.Context, arg2 string, arg3 ...trace.SpanStartOption) (context.Context, trace.Span) {
	fake.startSpanFromMutex.Lock()
	ret, specificReturn := fake.startSpanFromReturnsOnCall[len(fake.startSpanFromArgsForCall)]
	fake.startSpanFromArgsForCall = append(fake.startSpanFromArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []trace.SpanStartOption
	}{arg1, arg2, arg3})
	stub := fake.StartSpanFromStub
	fakeReturns := fake.startSpanFromReturns
	fake.recordInvocation("StartSpanFrom", []interface{}{arg1, arg2, arg3})
	fake.startSpanFromMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ParentContext) StartSpanFromCallCount() int {
	fake.startSpanFromMutex.RLock()
	defer fake.startSpanFromMutex.RUnlock()
	return len(fake.startSpanFromArgsForCall)
}

func (fake *ParentContext) StartSpanFromCalls(stub func(context.Context, string, ...trace.SpanStartOption) (context.Context, trace.Span)) {
	fake.startSpanFromMutex.Lock()
	defer fake.startSpanFromMutex.Unlock()
	fake.StartSpanFromStub = stub
}

func (fake *ParentContext) StartSpanFromArgsForCall(i int) (context.Context, string, []trace.SpanStartOption) {
	fake.startSpanFromMutex.RLock()
	defer fake.startSpanFromMutex.RUnlock()
	argsForCall := fake.startSpanFromArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *ParentContext) StartSpanFromReturns(result1 context.Context, result2 trace.Span) {
	fake.startSpanFromMutex.Lock()
	defer fake.startSpanFromMutex.Unlock()
	fake.StartSpanFromStub = nil
	fake.startSpanFromReturns = struct {
		result1 context.Context
		result2 trace.Span
	}{result1, result2}
}

func (fake *ParentContext) StartSpanFromReturnsOnCall(i int, result1 context.Context, result2 trace.Span) {
	fake.startSpanFromMutex.Lock()
	defer fake.startSpanFromMutex.Unlock()
	fake.StartSpanFromStub = nil
	if fake.startSpanFromReturnsOnCall == nil {
		fake.startSpanFromReturnsOnCall = make(map[int]struct {
			result1 context.Context
			result2 trace.Span
		})
	}
	fake.startSpanFromReturnsOnCall[i] = struct {
		result1 context.Context
		result2 trace.Span
	}{result1, result2}
}

func (fake *ParentContext) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	fake.contextMutex.RLock()
	defer fake.contextMutex.RUnlock()
	fake.disposeMutex.RLock()
	defer fake.disposeMutex.RUnlock()
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	fake.getSessionMutex.RLock()
	defer fake.getSessionMutex.RUnlock()
	fake.getSessionByIDMutex.RLock()
	defer fake.getSessionByIDMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.initiatorMutex.RLock()
	defer fake.initiatorMutex.RUnlock()
	fake.isMeMutex.RLock()
	defer fake.isMeMutex.RUnlock()
	fake.meMutex.RLock()
	defer fake.meMutex.RUnlock()
	fake.onErrorMutex.RLock()
	defer fake.onErrorMutex.RUnlock()
	fake.putSessionMutex.RLock()
	defer fake.putSessionMutex.RUnlock()
	fake.runViewMutex.RLock()
	defer fake.runViewMutex.RUnlock()
	fake.sessionMutex.RLock()
	defer fake.sessionMutex.RUnlock()
	fake.startSpanFromMutex.RLock()
	defer fake.startSpanFromMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ParentContext) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ view.ParentContext = new(ParentContext)
